{"ARM/Exceptions/Exception-Handling-Registers":{"title":"Exception Handling Registers","links":["ARM/Exceptions/DAIF","ARM/Exceptions/SPSel"],"tags":[],"content":"https://developer.arm.com/documentation/den0024/a/BABJGFCI\nTransclude of DAIF\nTransclude of SPSel"},"ARM/Exceptions/Exception-Levels":{"title":"Exception Levels","links":[],"tags":[],"content":"Exception Levels §\n\n\nEL3\n\nHighest privilege level is typically used for so called Secure Monitor\nEL3 firmware typically implements the Power State Coordination Interface (PSCI) for the lower ELs to use\nEL3 firmware typically involved into trusted boot\n\n\nEL2\n\nTargets the virtualization use-case\nEL at which hypervisors normally use for virtualization purposes.\n\n\nEL1\n\nPrivileged parts of the OS kernels use\n\n\nEL0\n\nMost unprivileged level\nRuns most unprivileged codes (userspace application, userspace drivers, etc).\n\n\n\nReference §\n\nhttps://developer.arm.com/documentation/102412/0103/Privilege-and-Exception-levels/Exception-levels\nhttps://krinkinmu.github.io/2021/01/04/aarch64-exception-levels.html\nhttps://medium.com/@om.nara/aarch64-exception-levels-60d3a74280e6\n"},"ARM/Exceptions/Exception-Vector-Table":{"title":"Exception Vector Table","links":[],"tags":[],"content":"AArch64 Exception Vector Table §\nARMv7 Exception Vector Table §\n\nReference: https://www.realdigital.org/doc/fb6974fbe87554b433bc0c6df2f14d69\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOffsetVectorMode0x00ResetSupervisor0x04Undefined InstructionUndefined0x08Supervisor CallSupervisor0x0CPrefetch AbortAbort0x10Data AbortAbort0x14Not UsedNA0x18IRQ InterruptIRQ0x1CFIQ InterruptFIQ\nARMv8 Exception Vector Table §\n\nReference: https://developer.arm.com/documentation/den0024/a/CHDEEDDC\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAddressException TypeDescriptionVBAR_ELn +0x000SynchronousCurrent EL with SP0+0x080IRQ/vIRQ^+0x100FIQ/vFIQ^+0x180SError/vSError^+0x200SynchronousCurrent EL with SPx+0x280IRQ/vIRQ^+0x300FIQ/vFIQ^+0x380SError/vSError^+0x400SynchronousLower EL using AArch64+0x480IRQ/vIRQ^+0x500FIQ/vFIQ^+0x580SError/vSError^+0x600SynchronousLower EL using AArch32+0x680IRQ/vIRQ^+0x700FIQ/vFIQ^+0x780SError/vSError^"},"ARM/Exceptions/Interrupt":{"title":"Interrupt","links":[],"tags":[],"content":"ARM Interrupt Structure §\nhttps://www.geeksforgeeks.org/arm-interrupt-structure/\nGIC §\nhttps://wiki.osdev.org/Generic_Interrupt_Controller_versions_3_and_4\nInterrupt Types §\n\nDifference between SGI PPI SPI: https://stackoverflow.com/questions/27709349/what-is-the-difference-between-ppi-spi-and-sgi-interrupts\n\nSGI: Software Generated Interrupt\nPPI: Private Peripheral Interrupt\nSPI: Shared Peripheral Interrupt\n\n\n\nInterrupt Trigger Types §\n\n\nEdge Triggered\n\n\nLevel Sensitive\n\n\nhttps://developer.arm.com/documentation/198123/0302/Arm-GIC-fundamentals\n\n"},"ARM/Exceptions/index":{"title":"index","links":["ARM/Exceptions/Interrupt","ARM/Exceptions/Exception-Levels","ARM/Exceptions/Exception-Vector-Table"],"tags":[],"content":"Transclude of Interrupt\nException Levels §\nTransclude of Exception-Levels\nException Handling §\nhttps://developer.arm.com/documentation/dui0471/m/handling-processor-exceptions/exception-handling-process\nhttps://developer.arm.com/documentation/100933/0100/Exception-handling\nhttps://developer.arm.com/documentation/den0024/a/AArch64-Exception-Handling/Interrupt-handling\nException Vector §\nTransclude of Exception-Vector-Table\nReference §\n\nhttps://velog.io/@coral2cola/ARM-Interrupts-1\nhttps://velog.io/@coral2cola/ARM-Interrupts-2\nhttps://grasslab.github.io/osdi/en/labs/lab3.html\n"},"ARM/Instructions/DMB-DSB-ISB":{"title":"DMB DSB ISB","links":[],"tags":[],"content":"https://blog.naver.com/signal97/221044676429\nhttps://tot0rokr.github.io/arm64/barrier/pipeline-barrier-isb-dmb-dsb-ordering/\nhttps://developer.arm.com/documentation/dui0489/c/arm-and-thumb-instructions/miscellaneous-instructions/dmb—dsb—and-isb\nDMB (Data Memory Barrier) §\nhttps://developer.arm.com/documentation/ddi0602/2023-12/Base-Instructions/DMB—Data-Memory-Barrier-?lang=en\nData Memory Barrier is a memory barrier that ensures the ordering of observations of memory accesses, see Data Memory Barrier.\nDSB (Data Synchronization Barrier) §\nhttps://developer.arm.com/documentation/ddi0602/2023-12/Base-Instructions/DSB—Data-Synchronization-Barrier-?lang=en\nData Synchronization Barrier is a memory barrier that ensures the completion of memory accesses, see Data Synchronization Barrier.\nISB (Instruction Synchronization Barrier) §\nInstruction Synchronization Barrier flushes the pipeline in the PE and is a context synchronization event. For more information, see Instruction Synchronization Barrier (ISB).\nhttps://developer.arm.com/documentation/ddi0602/2023-12/Base-Instructions/ISB—Instruction-Synchronization-Barrier-?lang=en"},"ARM/Instructions/MRS-MSR":{"title":"MSR MSR","links":["tags/imm","ARM/Registers/Program-Status-Registers-(PSR)/CPSR","ARM/Registers/Program-Status-Registers-(PSR)/SPSR"],"tags":["imm"],"content":"MSR §\nhttps://developer.arm.com/documentation/dui0068/b/ARM-Instruction-Reference/Miscellaneous-ARM-instructions/MSR\nLoads specified fields of the CPSR1 or SPSR2 with an#imm or\nMRS §\nhttps://developer.arm.com/documentation/dui0068/b/ARM-Instruction-Reference/Miscellaneous-ARM-instructions/MRS\n\nMove the contents of the CPSR or SPSR to general purpose register\nMove System Register to general-purpose register\n\nMRS{cond} Rd, psr\nFootnotes §\n\n\nCurrent Program Status Register CPSR ↩\n\n\nSaved Program Status Register SPSR ↩\n\n\n"},"ARM/Instructions/STP":{"title":"STP","links":[],"tags":[],"content":"STP: Store Pair of Registers §\nhttps://developer.arm.com/documentation/ddi0602/2023-12/Base-Instructions/STP—Store-Pair-of-Registers-?lang=en\n\nCalculates an address from a base register value and an immediate offset, and stores two 32bit words or two 64bit\ndoublewords to the calculated address, from two registers.q\n\nhttps://blog.naver.com/PostView.naver?blogId=crushhh&amp;logNo=222386913294\nUsage §\nPost-index §\nSTP &lt;Wt1&gt;, &lt;Wt2&gt;, [&lt;Xn|SP&gt;], #&lt;imm&gt;\nSTP &lt;Xt1&gt;, &lt;Xt2&gt;, [&lt;Xn|SP&gt;], #&lt;imm&gt;\nPre-index §\nSTP &lt;Wt1&gt;, &lt;Wt2&gt;, [&lt;Xn|SP&gt;, #&lt;imm&gt;]!\nSTP &lt;Xt1&gt;, &lt;Xt2&gt;, [&lt;Xn|SP&gt;, #&lt;imm&gt;]!\n\nSP를 &lt;imm&gt; 만큼 이동\nSP, #&lt;imm&gt; 주소: Xt1 저장\nSP, #&lt;imm&gt; 주소 + 0x8: Xt1 저장\n\nSigned offset §\nSTP &lt;Wt1&gt;, &lt;Wt2&gt;, [&lt;Xn|SP&gt;{, #&lt;imm&gt;}]\nSTP &lt;Xt1&gt;, &lt;Xt2&gt;, [&lt;Xn|SP&gt;{, #&lt;imm&gt;}]\nArmv7"},"ARM/Instructions/cmp":{"title":"cmp","links":[],"tags":[],"content":"https://developer.arm.com/documentation/107829/0200/Test-instructions—branching—and-loops"},"ARM/Instructions/index":{"title":"A-Profile A64 Instructions","links":[],"tags":[],"content":"https://developer.arm.com/documentation/ddi0602/2023-12/"},"ARM/Learn-the-architecture/AArch64-memory-management":{"title":"AArch64 memory management","links":[],"tags":[],"content":""},"ARM/Learn-the-architecture/Learn-The-Architecture":{"title":"Learn The Architecture","links":[],"tags":[],"content":"Assembly Basics §\nRegisters and Modes: https://computersource.tistory.com/71\nSpecial Purpose Registers: https://computersource.tistory.com/72\nAssembly: https://pu1et-panggg.tistory.com/11\nhttps://kyuhyuk.kr/article/simple-arm-operating-system/2019/03/04/Simple-ARM-Operating-System-Chapter2\nException Model §\nhttps://developer.arm.com/documentation/102412/0103"},"ARM/PL011/Interrupts":{"title":"Interrupts","links":[],"tags":[],"content":"Interrupt Registers §\nUARTICR: Interrupt Clear Register §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBitsNameFunction15:11ReservedReserved, read as zero, do not modify.10OEICOverrun error interrupt clear. Clears the UARTOEINTR interrupt.9BEICBreak error interrupt clear. Clears the UARTBEINTR interrupt.8PEICParity error interrupt clear. Clears the UARTPEINTR interrupt.7FEICFraming error interrupt clear. Clears the UARTFEINTR interrupt.6RTICReceive timeout interrupt clear. Clears the UARTRTINTR interrupt.5TXICTransmit interrupt clear. Clears the UARTTXINTR interrupt.4RXICReceive interrupt clear. Clears the UARTRXINTR interrupt.3DSRMICnUARTDSR modem interrupt clear. Clears the UARTDSRINTR interrupt.2DCDMICnUARTDCD modem interrupt clear. Clears the UARTDCDINTR interrupt.1CTSMICnUARTCTS modem interrupt clear. Clears the UARTCTSINTR interrupt.0RIMICnUARTRI modem interrupt clear. Clears the UARTRIINTR interrupt.\nUARTIFLS: Interrupt FIFO Level Select Register §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBitsNameFunction15:6-Reserved, do not modify, read as zero.5:3RXIFLSELReceive interrupt FIFO level select. The trigger points for the receive interrupt are as follows:b000 = Receive FIFO becomes ≥ 1/8 fullb001 = Receive FIFO becomes ≥ 1/4 fullb010 = Receive FIFO becomes ≥ 1/2 fullb011 = Receive FIFO becomes ≥ 3/4 fullb100 = Receive FIFO becomes ≥ 7/8 fullb101-b111 = reserved.2:0TXIFLSELTransmit interrupt FIFO level select. The trigger points for the transmit interrupt are as follows:b000 = Transmit FIFO becomes ≤ 1/8 fullb001 = Transmit FIFO becomes ≤ 1/4 fullb010 = Transmit FIFO becomes ≤ 1/2 fullb011 = Transmit FIFO becomes ≤ 3/4 fullb100 = Transmit FIFO becomes ≤ 7/8 fullb101-b111 = reserved.\nUARTIMSC: Interrupt Mask.Set.Clear Register §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBitsNameFunction15:11-Reserved, read as zero, do not modify.10OEIMOverrun error interrupt mask. A read returns the current mask for the UARTOEINTRinterrupt.On a write of 1, the mask of the UARTOEINTR interrupt is set. A write of 0 clears the mask.9BEIMBreak error interrupt mask. A read returns the current mask for the UARTBEINTRinterrupt.On a write of 1, the mask of the UARTBEINTR interrupt is set. A write of 0 clears the mask.8PEIMParity error interrupt mask. A read returns the current mask for the UARTPEINTRinterrupt.On a write of 1, the mask of the UARTPEINTR interrupt is set. A write of 0 clears the mask.7FEIMFraming error interrupt mask. A read returns the current mask for the UARTFEINTRinterrupt.On a write of 1, the mask of the UARTFEINTR interrupt is set. A write of 0 clears the mask.6RTIMReceive timeout interrupt mask. A read returns the current mask for the UARTRTINTRinterrupt.On a write of 1, the mask of the UARTRTINTR interrupt is set. A write of 0 clears the mask.5TXIMTransmit interrupt mask. A read returns the current mask for the UARTTXINTRinterrupt.On a write of 1, the mask of the UARTTXINTR interrupt is set. A write of 0 clears the mask.4RXIMReceive interrupt mask. A read returns the current mask for the UARTRXINTRinterrupt.On a write of 1, the mask of the UARTRXINTR interrupt is set. A write of 0 clears the mask.3DSRMIMnUARTDSR modem interrupt mask. A read returns the current mask for the UARTDSRINTR interrupt.On a write of 1, the mask of the UARTDSRINTR interrupt is set. A write of 0 clears the mask.2DCDMIMnUARTDCD modem interrupt mask. A read returns the current mask for the UARTDCDINTR interrupt.On a write of 1, the mask of the UARTDCDINTR interrupt is set. A write of 0 clears the mask.1CTSMIMnUARTCTS modem interrupt mask. A read returns the current mask for the UARTCTSINTR interrupt.On a write of 1, the mask of the UARTCTSINTR interrupt is set. A write of 0 clears the mask.0RIMIMnUARTRI modem interrupt mask. A read returns the current mask for the UARTRIINTR interrupt.On a write of 1, the mask of the UARTRIINTR interrupt is set. A write of 0 clears the mask.\nUARTMIS: Masked Interrupt Status Register §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBitsNameFunction15:11-Reserved, read as zero, do not modify10OEMISOverrun error masked interrupt status. Returns the masked interrupt state of the UARTOEINTR interrupt.9BEMISBreak error masked interrupt status. Returns the masked interrupt state of the UARTBEINTR interrupt.8PEMISParity error masked interrupt status. Returns the masked interrupt state of the UARTPEINTR interrupt.7FEMISFraming error masked interrupt status. Returns the masked interrupt state of the UARTFEINTR interrupt.6RTMISReceive timeout masked interrupt status. Returns the masked interrupt state of the UARTRTINTR interrupt.5TXMISTransmit masked interrupt status. Returns the masked interrupt state of the UARTTXINTR interrupt.4RXMISReceive masked interrupt status. Returns the masked interrupt state of the UARTRXINTR interrupt.3DSRMMISnUARTDSR modem masked interrupt status. Returns the masked interrupt state of the UARTDSRINTR interrupt.2DCDMMISnUARTDCD modem masked interrupt status. Returns the masked interrupt state of the UARTDCDINTR interrupt.1CTSMMISnUARTCTS modem masked interrupt status. Returns the masked interrupt state of the UARTCTSINTR interrupt.0RIMMISnUARTRI modem masked interrupt status. Returns the masked interrupt state of the UARTRIINTR interrupt."},"ARM/PL011/Registers":{"title":"Registers","links":[],"tags":[],"content":"https://developer.arm.com/documentation/ddi0183/g/programmers-model/summary-of-registers?lang=en\nUARTDR §\n\nData Register\nWriting to this register initiates the actual data transmission\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBitsNameFunction15:12-Reserved.11OEOverrun error. This bit is set to 1 if data is received and the receive FIFO is already full.This is cleared to 0 once there is an empty space in the FIFO and a new character can be written to it.10BEBreak error. This bit is set to 1 if a break condition was detected, indicating that the received data input was held LOW for longer than a full-word transmission time (defined as start, data, parity and stop bits).In FIFO mode, this error is associated with the character at the top of the FIFO. When a break occurs, only one 0 character is loaded into the FIFO. The next character is only enabled after the receive data input goes to a 1 (marking state), and the next valid start bit is received.9PEParity error. When set to 1, it indicates that the parity of the received data character does not match the parity that the EPS and SPS bits in the Line Control Register, UARTLCR_H select.In FIFO mode, this error is associated with the character at the top of the FIFO.8FEFraming error. When set to 1, it indicates that the received character did not have a valid stop bit (a valid stop bit is 1).In FIFO mode, this error is associated with the character at the top of the FIFO.7:0DATAReceive (read) data character.Transmit (write) data character.\nUARTFR §\n\nFlag Register\nCheck if transmission is complete\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBitsNameFunction15:9-Reserved, do not modify, read as zero.8RIRing indicator. This bit is the complement of the UART ring indicator, nUARTRI, modem status input. That is, the bit is 1 when nUARTRI is LOW.7TXFETransmit FIFO empty. The meaning of this bit depends on the state of the FEN bit in the Line Control Register, UARTLCR_H.If the FIFO is disabled, this bit is set when the transmit holding register is empty.If the FIFO is enabled, the TXFE bit is set when the transmit FIFO is empty.This bit does not indicate if there is data in the transmit shift register.6RXFFReceive FIFO full. The meaning of this bit depends on the state of the FEN bit in the UARTLCR_H Register.If the FIFO is disabled, this bit is set when the receive holding register is full.If the FIFO is enabled, the RXFF bit is set when the receive FIFO is full.5TXFFTransmit FIFO full. The meaning of this bit depends on the state of the FEN bit in the UARTLCR_H Register.If the FIFO is disabled, this bit is set when the transmit holding register is full.If the FIFO is enabled, the TXFF bit is set when the transmit FIFO is full.4RXFEReceive FIFO empty. The meaning of this bit depends on the state of the FEN bit in the UARTLCR_H Register.If the FIFO is disabled, this bit is set when the receive holding register is empty.If the FIFO is enabled, the RXFE bit is set when the receive FIFO is empty.3BUSYUART busy. If this bit is set to 1, the UART is busy transmitting data. This bit remains set until the complete byte, including all the stop bits, has been sent from the shift register.This bit is set as soon as the transmit FIFO becomes non-empty, regardless of whether the UART is enabled or not.2DCDData carrier detect. This bit is the complement of the UART data carrier detect, nUARTDCD, modem status input. That is, the bit is 1 when nUARTDCD is LOW.1DSRData set ready. This bit is the complement of the UART data set ready, nUARTDSR, modem status input. That is, the bit is 1 when nUARTDSR is LOW.0CTSClear to send. This bit is the complement of the UART clear to send, nUARTCTS, modem status input. That is, the bit is 1 when nUARTCTS is LOW.\nUARTIBRD, UARTFBRD §\n\nResponsible for the speed\n\nUARTIBRD §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBitsNameFunction15:0BAUD DIVINTThe integer baud rate divisor.These bits are cleared to 0 on reset.\nUARTFBRD §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBitsNameFunction5:0BAUD DIVFRACThe fractional baud rate divisor.These bits are cleared to 0 on reset.\nUARTLCR_H §\n\nLine Control Register\nControls the Data Frame Format\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBitsNameFunction15:8-Reserved, do not modify, read as zero.7SPSStick parity select.0 = stick parity is disabled1 = either:- if the EPS bit is 0 then the parity bit is transmitted and checked as a 1    - if the EPS bit is 1 then the parity bit is transmitted and checked as a 0.    This bit has no effect when the PEN bit disables parity checking and generation. See Table 3.11 for the parity truth table.6:5WLENWord length. These bits indicate the number of data bits transmitted or received in a frame as follows:b11 = 8 bitsb10 = 7 bitsb01 = 6 bitsb00 = 5 bits.4FENEnable FIFOs:0 = FIFOs are disabled (character mode) that is, the FIFOs become 1-byte-deep holding registers1 = transmit and receive FIFO buffers are enabled (FIFO mode).3STP2Two stop bits select. If this bit is set to 1, two stop bits are transmitted at the end of the frame. The receive logic does not check for two stop bits being received.2EPSEven parity select. Controls the type of parity the UART uses during transmission and reception:0 = odd parity. The UART generates or checks for an odd number of 1s in the data and parity bits.1 = even parity. The UART generates or checks for an even number of 1s in the data and parity bits.This bit has no effect when the PEN bit disables parity checking and generation. See Table 3.11 for the parity truth table.1PENParity enable:0 = parity is disabled and no parity bit added to the data frame1 = parity checking and generation is enabled.See Table 3.11 for the parity truth table.0BRKSend break. If this bit is set to 1, a low-level is continually output on the UARTTXD output, after completing transmission of the current character. For the proper execution of the break command, the software must set this bit for at least two complete frames.For normal use, this bit must be cleared to 0.\nUARTCR §\n\nUART Control Register\nCan Enable/Disable UART, Transmission or Reception\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBitsNameFunction15CTSEnCTS hardware flow control enable. If this bit is set to 1, CTS hardware flow control is enabled. Data is only transmitted when the nUARTCTS signal is asserted.14RTSEnRTS hardware flow control enable. If this bit is set to 1, RTS hardware flow control is enabled. Data is only requested when there is space in the receive FIFO for it to be received.13Out2This bit is the complement of the UART Out2 (nUARTOut2) modem status output. That is, when the bit is programmed to a 1, the output is 0. For DTE this can be used as Ring Indicator (RI).12Out1This bit is the complement of the UART Out1 (nUARTOut1) modem status output. That is, when the bit is programmed to a 1 the output is 0. For DTE this can be used as Data Carrier Detect (DCD).11RTSRequest to send. This bit is the complement of the UART request to send, nUARTRTS, modem status output. That is, when the bit is programmed to a 1 then nUARTRTS is LOW.10DTRData transmit ready. This bit is the complement of the UART data transmit ready, nUARTDTR, modem status output. That is, when the bit is programmed to a 1 then nUARTDTR is LOW.9RXEReceive enable. If this bit is set to 1, the receive section of the UART is enabled. Data reception occurs for either UART signals or SIR signals depending on the setting of the SIREN bit. When the UART is disabled in the middle of reception, it completes the current character before stopping.8TXETransmit enable. If this bit is set to 1, the transmit section of the UART is enabled. Data transmission occurs for either UART signals, or SIR signals depending on the setting of the SIREN bit. When the UART is disabled in the middle of transmission, it completes the current character before stopping.7LBELoopback enable. If this bit is set to 1 and the SIREN bit is set to 1 and the SIRTEST bit in the Test Control Register, UARTTCR is set to 1, then the nSIROUT path is inverted, and fed through to the SIRIN path. The SIRTEST bit in the test register must be set to 1 to override the normal half-duplex SIR operation. This must be the requirement for accessing the test registers during normal operation, and SIRTEST must be cleared to 0 when loopback testing is finished. This feature reduces the amount of external coupling required during system test.If this bit is set to 1, and the SIRTEST bit is set to 0, the UARTTXD path is fed through to the UARTRXD path.In either SIR mode or UART mode, when this bit is set, the modem outputs are also fed through to the modem inputs.This bit is cleared to 0 on reset, to disable loopback.6:3-Reserved, do not modify, read as zero.2SIRLPSIR low-power IrDA mode. This bit selects the IrDA encoding mode. If this bit is cleared to 0, low-level bits are transmitted as an active high pulse with a width of 3/16th of the bit period. If this bit is set to 1, low-level bits are transmitted with a pulse width that is 3 times the period of the IrLPBaud16 input signal, regardless of the selected bit rate. Setting this bit uses less power, but might reduce transmission distances.1SIRENSIR enable:0 = IrDA SIR ENDEC is disabled. nSIROUT remains LOW (no light pulse generated), and signal transitions on SIRIN have no effect.1 = IrDA SIR ENDEC is enabled. Data is transmitted and received on nSIROUT and SIRIN. UARTTXD remains HIGH, in the marking state. Signal transitions on UARTRXD or modem status inputs have no effect.This bit has no effect if the UARTEN bit disables the UART.0UARTENUART enable:0 = UART is disabled. If the UART is disabled in the middle of transmission or reception, it completes the current character before stopping.1 = the UART is enabled. Data transmission and reception occurs for either UART signals or SIR signals depending on the setting of the SIREN bit."},"ARM/PL011/index":{"title":"PL011 UART","links":[],"tags":[],"content":"\nDocumentation: https://developer.arm.com/documentation/ddi0183/g?lang=en\nPDF: https://documentation-service.arm.com/static/5e8e36c2fd977155116a90b5?token=\nReference: https://krinkinmu.github.io/2020/11/29/PL011.html\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOffsetNameTypeResetWidthDescription0x000UARTDRRW0x---12/8Data Register, UARTDR0x004UARTRSR/ UARTECRRW0x04/0Receive Status Register / Error Clear Register, UARTRSR/UARTECR0x008-0x014----Reserved0x018UARTFRRO0b-10010---9Flag Register, UARTFR0x01C----Reserved0x020UARTILPRRW0x008IrDA Low-Power Counter Register, UARTILPR0x024UARTIBRDRW0x000016Integer Baud Rate Register, UARTIBRD0x028UARTFBRDRW0x006Fractional Baud Rate Register, UARTFBRD0x02CUARTLCR_HRW0x008Line Control Register, UARTLCR_H0x030UARTCRRW0x030016Control Register, UARTCR0x034UARTIFLSRW0x126Interrupt FIFO Level Select Register, UARTIFLS0x038UARTIMSCRW0x00011Interrupt Mask Set/Clear Register, UARTIMSC0x03CUARTRISRO0x00-11Raw Interrupt Status Register, UARTRIS0x040UARTMISRO0x00-11Masked Interrupt Status Register, UARTMIS0x044UARTICRWO-11Interrupt Clear Register, UARTICR0x048UARTDMACRRW0x003DMA Control Register, UARTDMACR0x04C-0x07C----Reserved0x080-0x08C----Reserved for test purposes0x090-0xFCC----Reserved0xFD0-0xFDC----Reserved for future ID expansion0xFE0UARTPeriphID0RO0x118UARTPeriphID0 Register0xFE4UARTPeriphID1RO0x108UARTPeriphID1 Register0xFE8UARTPeriphID2RO0x_4[1]8UARTPeriphID2 Register0xFECUARTPeriphID3RO0x008UARTPeriphID3 Register0xFF0UARTPCellID0RO0x0D8UARTPCellID0 Register0xFF4UARTPCellID1RO0xF08UARTPCellID1 Register0xFF8UARTPCellID2RO0x058UARTPCellID2 Register0xFFCUARTPCellID3RO0xB18UARTPCellID3 Register\nReference §\nhttps://krinkinmu.github.io/2020/11/29/PL011.html"},"ARM/Processor-Modes":{"title":"Processor Modes","links":[],"tags":[],"content":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nModeDescriptionCPSR M[4:0]UserUser Task나 Application을 수항 할때의 동작모드로 모든 동작모드 중 유일하게 비특권 모드이다. User Mode는 메모리, I/O장치와 같은 시스템 자원을 사용하는데 제한을 두어 사용자의 실수를 방지한다. 다른 모드(SVC)로 이동하기 위한 방법으로는 소프트웨어 인터럽트를 발생시킨다.10000bFIQ(Fast IRQ)2개의 인터럽트 소스 중 아주 빠르게 인터럽트를 처리할 수 있도록 구성된 모드이다. 빠른 처리를 위해서 Exception Vector에서도 최하단에 존재하고 별도의 레지스터를 소유한다.10001bIRQ(Interrupt Request)일반적으로 사용되는 인터럽트로 외부 장치에서 요청되는 하드웨어적인 IRQ의 발생에 의해 ARM Core는 IRQ모드로 전환하고 인터럽트를 처리한다.10010bSVC(Superviser)대부분의 시스템 자원을 자유롭게 관리할 수 있는 동작모드로 주로 커널이나 디바이스 드라이버를 처리할 때(System Call) 동작되는 모드이다.Reset 신호 입력 시 및 SWI가 발생하면 SVC Mode로 전환된다.10011bAbort메모리에서 명령을 읽거나 데이터를 읽거나 쓸때 오류가 발생할 때 Abort Mode로 전환하여 오류를 처리한다. 커널등의 패닉시 Abort Mode로 전환되어 스택 내용이 전달됨을 알 수 있다.10111bUndefined명령어를 읽어 실행하고자 하나 읽어온 명령이 디코더에 정의되어 있지 않은 명령인 경우 발생되는 오류를 처리하는 모드이다.11011bSystemUser Mode와 동일한 Register를 사용하고 동일한 용도로 사용된다. User Mode와의 차이점은 특권을 갖고 있다는 것이다. (ex : OS Kernel)11111b\nhttps://julrams.tistory.com/12"},"ARM/Programmer's-Guide/Chapter-12-The-Memory-Management-Unit":{"title":"Chapter 12 The Memory Management Unit","links":[],"tags":[],"content":"\n12.1 TLB (Translation Lookaside Buffer) §\n\nTLB Entry\n\nPhysical Address\nVirtual Address\nMemory Type\nCache Policies\nAccess Permissions\nASID (Address Space ID)\nVMID (Virtual Machine ID)\n\n\nTLB miss\n\nExternal Translation Table Walk / Lookup is performed\n\n\n\nTLBI &lt;type&gt;&lt;level&gt;{IS} {, &lt;Xt&gt;}\n12.2 Separation of kernel and application Virtual Address spaces §\nTranslation Table Base Registers (TTBR0_EL1, TTBR1_EL1) §\n\nTTBR0: when upper bits of the VA are all 0\n\nEL2, EL3 has it\n\n\nTTBR1: when upper bits of the VA are all 1\n\nEL2, EL3 doesn’t have it\n\n\n\n"},"ARM/Registers/DAIF":{"title":"DAIF","links":[],"tags":[],"content":"DAIF: Interrupt Mask Bits §\nAllows access to the interrupt mask bits.\nhttps://developer.arm.com/documentation/ddi0601/2023-12/AArch64-Registers/DAIF—Interrupt-Mask-Bits\nD bit[9] §\nDebug\nWhether to mask Watchpoint, Breakpoint, Software Step exceptions targeted at the current Exception Level\nWhen the target Exception level of debug exception is higher than the current Exception level, the exception will not be masked by D\nDefaults to 1 on warm reset\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDMeaning0not masked1masked\nA bit[8] §\nSError(SystemError) Exception mask bit\nDefaults to 1 on warm reset\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAMeaning0Exception not masked1Exception masked\nI bit[7] §\nIRQ mask bit\nDefaults to 1 on warm reset\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIMeaning0Exception not masked1Exception masked\nF bit[6] §\nFIQ mask bit\nDefaults to 1 on warm reset\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFMeaning0Exception not masked1Exception masked"},"ARM/Registers/HCR_EL2":{"title":"HCR_EL2","links":[],"tags":[],"content":"HCR_EL2 §\n\nPurpose: Provides configuration controls for virtualization, including defining whether various operations are trapped to EL2.\nReference: https://developer.arm.com/documentation/ddi0601/2024-03/AArch64-Registers/HCR-EL2—Hypervisor-Configuration-Register\n"},"ARM/Registers/ICC_SGI1R_EL1":{"title":"ICC_SGI1R_EL1","links":[],"tags":[],"content":"https://developer.arm.com/documentation/ddi0601/2020-12/AArch64-Registers/ICC-SGI1R-EL1—Interrupt-Controller-Software-Generated-Interrupt-Group-1-Register"},"ARM/Registers/Program-Status-Registers-(PSR)/APSR":{"title":"APSR","links":["ARM/Instructions/MRS","ARM/Instructions/MRS-MSR"],"tags":[],"content":"APSR: Application Program Status Register §\nhttps://developer.arm.com/documentation/ddi0595/2021-12/AArch32-Registers/APSR—Application-Program-Status-Register\nPurpose §\n\nHolds Program status\nHolds Control Information\n\nConfiguration §\n\nOnly present when AArch32 is supported.\n\nAttributes §\n\n32bit register\n\nAccessing APSR §\n\nRead\n\nMRS\n\n\nWrite\n\nMRS MSR (register)\nMRS MSR (immediate)\n\n\n\nField Descriptions §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n313029282726~232221~2019~1615~10987654~0NZCVQRES0PANRES0GERES0EAIFRES0M\nN bit[31] §\n\nNegative Condition Flag\n\nZ bit[30] §\n\nZero Condition Flag\nField\n\n1: the result of the last flag-setting inst. was zero\n0: otherwise\n\n\n\nC bit[29] §\n\nCarry Condition Flag\nField\n\n1: the last flag-setting instruction resulted in a carry condition\n0: otherwise\n\n\n\nV bit[28] §\n\nOverflow Condition Flag\nField\n\n1: the last flag-setting instruction resulted in an overflow condition\n0: otherwise\n\n\n\nQ bit[27] §\n\nCumulative Saturation Bit\nField\n\n1: indicates overflow or saturation occurred in some instructions.\n0: otherwise\n\n\n\nPAN bit[22] §\n\nPrivileged Access Never\n\nGE bit[15:10] §\n\nGreater than or Equal flags\nFor Parallel addition and subtraction\n\nE bit[9] §\n\nEndianess\n\nA bit[8] §\nSError(SystemError) Exception mask bit\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAMeaning0Exception not masked1Exception masked\nI bit[7] §\nIRQ mask bit\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIMeaning0Exception not masked1Exception masked\nF bit[6] §\nFIQ mask bit\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFMeaning0Exception not masked1Exception masked\n"},"ARM/Registers/Program-Status-Registers-(PSR)/CPSR":{"title":"CPSR","links":[],"tags":[],"content":"CPSR: Current Program Status Register §\nhttps://developer.arm.com/documentation/ddi0601/2023-12/AArch32-Registers/CPSR—Current-Program-Status-Register?lang=en\nhttps://developer.arm.com/documentation/dui0473/m/overview-of-the-arm-architecture/current-program-status-register\n\nAPSR flags\nProcessor Mode\nInterrupt Disable Flags\nThe Instruction set state (ARM, Thumb, ThumbEE or Jazelle)\nThe endianness state (ARMv4tT and later)\nThe execution state bits for the IT block (ARMv6T2 and later)\n\nFields §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n313029282726~242322212019~1615~109876543~0NZCVQRES0SSBSPANDITRES0GERES0EAIFRES0RES1M\nE bit[9] §\n\nEndianness State bit\n| E   | Meaning                 |\n| --- | ----------------------- |\n| 0b0 | Little-Endian Operation |\n| 0b1 | Big-Endian Operation    |\n\nA bit[8] §\nSError(SystemError) Exception mask bit\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAMeaning0Exception not masked1Exception masked\nI bit[7] §\nIRQ mask bit\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIMeaning0Exception not masked1Exception masked\nF bit[6] §\nFIQ mask bit\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFMeaning0Exception not masked1Exception masked\nM bit[3:0] §\n\nCurrent PE Mode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMMeaning0b0000User0b0001FIQ0b0010IRQ0b0011Supervisor0b0110Monitor0b01111Abort0b1010Hyp.0b1011Undefined0b1111System"},"ARM/Registers/Program-Status-Registers-(PSR)/SPSR":{"title":"SPSR","links":[],"tags":[],"content":"SPSR: Saved Program Status Register §\nhttps://developer.arm.com/documentation/ddi0601/2023-12/AArch32-Registers/SPSR—Saved-Program-Status-Register\n\nSaves the current CPSR when an exception is taken..\nso that CPSR can be restored after exception handling\n"},"ARM/Registers/Program-Status-Registers-(PSR)/index":{"title":"Program Status Registers","links":[],"tags":[],"content":"https://lioncash.github.io/ARMBook/the_apsr,_cpsr,_and_the_difference_between_them.html"},"ARM/Registers/SPSel":{"title":"SPSel","links":[],"tags":[],"content":"SPSel §\n\nPurpose: Allows the Stack Pointer to be selected between SP_EL0 and SP_ELx.\nReference: https://developer.arm.com/documentation/ddi0601/2023-12/AArch64-Registers/SPSel—Stack-Pointer-Select\n"},"ARM/Registers/VBAR_EL1":{"title":"VBAR_EL1","links":[],"tags":[],"content":"VBAR_EL1 §\n\nPurpose: Holds the vector base address for any exception that is taken to EL1.\nReference: https://developer.arm.com/documentation/ddi0601/2024-03/AArch64-Registers/VBAR-EL1—Vector-Base-Address-Register—EL1-?lang=en\n"},"ARM/Registers/index":{"title":"A-Profile Registers","links":["ARM/Processor-Modes","ARM/Registers/Program-Status-Registers-(PSR)/"],"tags":[],"content":"https://developer.arm.com/documentation/ddi0601/2023-12/AArch64-Registers\nhttps://velog.io/@yyj0110/arm-registers\nProcessor-Modes\nARM Registers by state §\n\n\nSpecial Purpose Register §\nR13: Stack Pointer (SP) §\n\nCurrent Stack\n\nR14: Link Register (LR) §\n\n함수호출되어 branch 하기 전 되돌아갈 함수 주소 저장\n\nR15: Program Counter (PC) §\n\n다음 실행할 명령어 주소 저장\n\nPSR: Program Status Register §\nSpecial Registers §\nhttps://developer.arm.com/documentation/den0024/a/ARMv8-Registers/AArch64-special-registers\n"},"ARM/Timer":{"title":"Timer","links":[],"tags":[],"content":"https://developer.arm.com/documentation/102379/0101/The-processor-timers?lang=en\nCount &amp; Freq §\n\nCNTPCT_EL0\n\nCurrent System Count Value\n\n\nCNTFRQ_EL0\n\nFrequency of the System Count\nWrite-able at the highest implemented EL, Readable at all EL\n\n\n\nRegisters §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRegisterPurpose&lt;timer&gt;_CTL_EL&lt;x&gt;Control register&lt;timer&gt;_CVAL_EL&lt;x&gt;Comparator value&lt;timer&gt;_TVAL_EL&lt;x&gt;Timer value\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTimerRegister prefixELEL1 physical timerCNTPEL0EL1 virtual timeCNTVEL0Non-secure EL2 physical timerCNTHPEL2Non-secure EL2 virtual timerCNTHVEL2EL3 physical timerCNTPSEL1Secure EL2 physical timerCNTHPSEL2Secure EL2 virtual timerCNTHVSEL2\nConfiguration §\nCVAL §\n\nComparator Register\n64bit\nTimer Condition Met: CVAL &lt;= System Count\n\nTVAL §\n\nTimer Register\n32bit\nTimer Condition Met: TVAL &lt;= 0\n\n정리 §\n\nCVAL은 System Count와 일치할 때..\nTVAL은 TVAL 만큼 Count한 이후에..\n\nInterrupts §\nCNTP_CTL §\n\nENABLE: Enables the timer\nIMASK: Interrupt Mask\nISTATUS: Reports whether the timer is firing (=CVAL &lt;= System Count) when ENABLE==1\n"},"ARM/Virtual-Memory":{"title":"Virtual Memory","links":[],"tags":[],"content":"ARM VMSA (Virtual Memory System Architecture) §\nVMSA Address Types &amp; Spaces §\nVA §\n\nMaximum address width: 48bits\nAddress Space Size: 256TB\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVA range countrangesubrangeTranslation stage with single VA Range0x0000 0000 0000 0000 ~ 0x0000 FFFF FFFF FFFFxTranslation stage with two VA Range0x0000 0000 0000 0000 ~ 0x0000 FFFF FFFF FFFF0x FFFF 0000 0000 0000 ~ 0xFFFF FFFF FFFF FFFF\n(Special Case) ARMv8.2-LVA Implemented &amp; 64KB translation granule §\n\nMaximum address width: 52bits\nAddress Space Size: 4PB\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVA range countrangesubrangeTranslation stage with single VA Range0x0000 0000 0000 0000 ~ 0x000F FFFF FFFF FFFFxTranslation stage with two VA Range0x0000 0000 0000 0000 ~ 0x000F FFFF FFFF FFFF0xFFF0 0000 0000 0000 ~ 0xFFFF FFFF FFFF FFFF\nTranslation stage with single VA Range §\nTranslation stage with two VA Ranges §\nVMSAv8-64 Descriptor formats §\nVMSAv8-64 Table Descriptor format §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOAGranule63 to 5958 to 515049 to 4847 to 1615 to 1413 to 1211 to 109 to 87 to 21052bit4KBAttributesIGNOREDRES0Next-level Table Address[49:12]&lt;&lt;&lt;IGNOREDNext-level Table Address[51:50]IGNORED1152bit16KBAttributesIGNOREDRES0Next-level Table Address[49:14]&lt;&lt;RES0IGNOREDNext-level Table Address[51:50]IGNORED1152bit64KBAttributesIGNOREDRES0&lt;Next-level Table Address[47:16]Next-level Table Address[51:48]&lt;&lt;&lt;&lt;1148bit4KBAttributesIGNOREDRES0&lt;Next-level Table Address[47:12]&lt;&lt;IGNORED&lt;&lt;1148bit16KBAttributesIGNOREDRES0&lt;Next-level Table Address[47:14]&lt;RES0IGNORED&lt;&lt;1148bit64KBAttributesIGNOREDRES0&lt;Next-level Table Address[47:16]RES0&lt;IGNORED&lt;&lt;11\nAttribute Field §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCondition6362~61605958~535251Stage 1NSTableAPTableUXNTable or XNTablePXNTable or RES0 or IGNOREDIGNOREDProtected or IGNOREDIGNOREDStage 2 with indirect permission disabledRES0RES0&lt;&lt;IGNORED&lt;&lt;Stage 2 with indirect permission enabledRES0IGNORED&lt;&lt;IGNORED&lt;&lt;\nVMSAv8-64 Page Descriptor format §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOAGranule63~5052bit4KB"},"Architecture/04_SOLID":{"title":"SOLID","links":[],"tags":[],"content":"What are SOLID Principles? §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPrincipleFull nameDescriptionSRPThe Single Responsibility PrincipleA class should have one, and only one, reason to change.OCPThe Open Closed PrincipleYou should be able to extend a classes behavior, without modifying it.LSPThe Liskov Substitution PrincipleDerived classes must be substitutable for their base classes.ISPThe Interface Segregation PrincipleMake fine grained interfaces that are client specific.DIPThe Dependency Inversion PrincipleDepend on abstractions, not on concretions.http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod\n단일 책임 원칙 SRP (Single Responsibility Principle) §\n\nA class should have one, and only one, reason to change.\n\n\nA module should be responsible to one, and only one, actor.\n\n목표 §\n\n클래스가 변경됐을 때 영향을 받는 액터가 하나여야 한다.\n클래스를 변경할 이유는 유일한 액터의 요구사항이 변경될 때로 제한되어야 한다.\n\n개방 폐쇄 원칙 OCP (Open-Closed Principle) §\n\nYou should be able to extend a classes behavior, without modifying it.\n\n리스코프 치환 원칙 LSP (Liskov Substitution Principle) §\n\nDerived classes must be substitutable for their base classes.\n\n인터페이스 분리 원칙 ISP (Interface Segregation Principle) §\n\nMake fine grained interfaces that are client specific\n"},"Flutter/Architecture":{"title":"Architecture","links":[],"tags":[],"content":"Reference §\nFlutter 인기 아키텍처 라이브러리 3종 비교 분석 - GetX vs BLoC vs Provider"},"Flutter/index":{"title":"Flutter","links":[],"tags":[],"content":""},"Linux/ELF":{"title":"ELF","links":[],"tags":[],"content":"https://refspecs.linuxbase.org/elf/\nELF Header §\nhttps://refspecs.linuxbase.org/elf/gabi4+/ch4.eheader.html\ntypedef struct elf64_phdr {\n    Elf64_Word p_type;\n    Elf64_Word p_flags;\n    Elf64_Off p_offset;\n    Elf64_Addr p_vaddr;\n    Elf64_Addr p_paddr;\n    Elf64_Xword p_filesz;\n    Elf64_Xword p_memsz;\n    Elf64_Xword p_align;\n} Elf64_Phdr;\nProgram Header §\nhttps://refspecs.linuxbase.org/elf/gabi4+/ch5.pheader.html\ntypedef struct {\n\tElf64_Word\tp_type;\n\tElf64_Word\tp_flags;\n\tElf64_Off\tp_offset;\n\tElf64_Addr\tp_vaddr;\n\tElf64_Addr\tp_paddr;\n\tElf64_Xword\tp_filesz;\n\tElf64_Xword\tp_memsz;\n\tElf64_Xword\tp_align;\n} Elf64_Phdr;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nnamemeaningp_typep_flagsp_offsetp_vaddrp_paddrp_fileszp_memszp_algin\nSection Header §\nhttps://refspecs.linuxbase.org/elf/gabi4+/ch4.sheader.html"},"Linux/Kernel-APIs/index":{"title":"Kernel API","links":[],"tags":[],"content":""},"Linux/Kernel-APIs/kernel-↔-user":{"title":"kernel ↔ user","links":[],"tags":["linux","api"],"content":"https://archive.kernel.org/oldlinux/htmldocs/kernel-api/API-cdev-init.html\n\n\nput_user(type val, type *address)\n\n#include &lt;asm/uaccess.h&gt;\nstore the value val to user space address address\ntype can be 8, 16, 32, 64 bit (depends on hardware)\n\n\n\nget_user(type val, type *address)\n\n#include &lt;asm/uaccess.h&gt;\nget the value val from user space address address\n\n\n\nunsigned long copy_to_user(void __user *to, const void *from, unsigned long n)\n\n#include &lt;linux/uaccess.h&gt;\ncopy nbytes from kernel-space to user-space\n\n\n\nunsigned long copy_from_user(void *to, const void __user *from, unsigned long n)\n\n#include &lt;linux/uaccess.h&gt;\ncopy n bytes from user-space to kernel-space\n\n\n"},"Linux/Kernel-APIs/mknod":{"title":"mknod","links":[],"tags":["linux","api"],"content":"Usage §\nmknod NAME TYPE [MAJOR MINOR]\n\nTYPE: b, c, p, u\nMAJOR: major number\nMINOR: minor number\n\nCreate a character device §\nmknod /dev/zero c 1 5"},"Linux/Kernel-Labs/00_Introduction":{"title":"Introduction","links":[],"tags":[],"content":""},"Linux/Kernel-Labs/03_Character-Device-Drivers":{"title":"Character Device Drivers","links":[],"tags":["linux","kernel"],"content":"Intro §\nUNIX 시스템에서는 모든 장치들을 파일로 취급한다. /dev 디렉토리에는 시스템에 연결된 모든 장치들이 파일 형태로 존재하고, open, write, close, lseek, mmap 등의 시스템 콜을 통해 운영체제에서 device driver로 접근할 수 있다.\nDevice Drivers: Character &amp; Block §\n\n나누는 기준\n\nspeed\nvolume\n시스템과 디바이스 간 데이터 전송 방식 {/* - way of organizing data to be transferred from the device to the system and vice versa */}\n\n\n\nCharacter Device Drivers §\n\n느린 장치들\n적은 양의 데이터를 관리한다.\n데이터에 접근하기 위해서 seek 쿼리를 자주 사용하지 않아도 됨\n주로, 이러한 장치들에서의 Operation(Read, Write)는 Byte 단위로 순차적으로 이루어짐\n예시: 키보드, 마우스, 시리얼 포트, 사운드 카드, 조이스틱 등\n\nBlock Device Drivers §\n\n데이터 볼륨이 큰 장치들\n블록 단위로 데이터를 관리하는 장치들\n검색이 잦은 장치들\n데이터 Block 단위로 Operation이 수행됨\n시스템 콜에 의해 직접 다룰 수 없고, 파일 관리 subsystem과 block device subsystem을 통해 user-space와 block device driver가 소통함\n예시: 하드 디스크, CD-ROM 드라이브, 램 등\n\nMajors and Minors §\n\nMajor: Device Type (IDE disk, SCSI disk, serial port 등)\nMinor: Device Instance (IDE disk 1, IDE disk 2, serial port 1, serial port 2 등)\n\n\nlinux/Documentation/admin-guide/devices.txt에서 모든 Major, Minor 번호를 확인할 수 있다.\n\nls -al $(find /dev -maxdepth 1 -type c) # character devices\nls -al $(find /dev -maxdepth 1 -type b) # block devices\nAllocation §\n\nStatic Allocation\nDynamic Allocation\n\nImplementation Steps §\n1. Create a Device File §\n\n직접 등록\n\nmknod &lt;device_file&gt; &lt;type&gt; &lt;major&gt; &lt;minor&gt;\nmknod /dev/mycdev c 42 0 # character device\nmknod /dev/mybdev b 42 0 # block device\n\n드라이버에서 자동등록\n\nstruct class *cls = class_create(device_name);\ndevice_create(cls, NULL, dev, NULL, &quot;d&quot;); //creates a device and registers it with sysfs\n\nDynamic Minor?\n\n2. Define Character Device Struct §\nstruct my_device_data {\n\tstruct cdev cdev;\n\t// My Data..\n}\n\ncan be accessed by\n\nfile-&gt;private_data\ncontainer_of(inode-&gt;i_cdev, struct my_device_data, cdev)\n\n\n\n3. Registration &amp; Unregistration §\n\nRegistration\n\nint register_cdev(void)\n{\n    int err = register_chrdev_region(MKDEV(MY_MAJOR, 0), MY_MAX_MINORS, &quot;my_device_driver&quot;);\n    if (err != 0) {\n        /* report error */\n        return err;\n    }\n \n    for(int i = 0; i &lt; MY_MAX_MINORS; i++) {\n        /* initialize devs[i] fields */\n        cdev_init(&amp;devs[i].cdev, &amp;my_fops);\n        cdev_add(&amp;devs[i].cdev, MKDEV(MY_MAJOR, i), 1);\n    }\n \n    return 0;\n}\n\nUnregistration\n\nvoid unregister_cdev(void)\n{\n    for(int i = 0; i &lt; MY_MAX_MINORS; i++) {\n        /* release devs[i] fields */\n        cdev_del(&amp;devs[i].cdev);\n    }\n    unregister_chrdev_region(MKDEV(MY_MAJOR, 0), MY_MAX_MINORS);\n}\n4. Implement Operations §\nstruct file_operations §\n\ndefine driver operations\nhttps://elixir.bootlin.com/linux/v6.7.2/source/include/linux/fs.h#L1916\n\nconst struct file_operations my_fops = {\n    .owner = THIS_MODULE,\n    .open = my_open,\n    .read = my_read,\n    .write = my_write,\n    .release = my_release,\n    .unlocked_ioctl = my_ioctl\n};\nOpen &amp; Release §\nRead &amp; Write §\nRead §\n\n\nstatic int my_open(struct inode *inode, struct file *file)\n{\n    struct my_device_data *my_data = container_of(inode-&gt;i_cdev, struct my_device_data, cdev);\n \n    /* validate access to device */\n    file-&gt;private_data = my_data;\n \n    /* initialize device */\n    ...\n \n    return 0;\n}\nWrite §\n\n\nIOCTL §\n\ninput/output control\n\n\nReference §\n\nChar Device API: https://docs.kernel.org/core-api/kernel-api.html#char-devices\nhttps://linux-kernel-labs.github.io/refs/heads/master/labs/device_drivers.html\n"},"Linux/Kernel-Labs/04_IO-access-and-Interrupts":{"title":"I/O access and Interrupts","links":[],"tags":["linux","kernel"],"content":"Objectives §\n\n주변장치와의 소통\nInterrupt Handler 구현\nSynchronizing interrupts with Process Context\n\nIntro §\nBackground Information §\nI/O Ports §\n\nDefinition: set of I/O addresses\ncan be mapped to physical memory addresses → communicate directly with the device through instructions\nport is differentiated by the number of bits: 8, 16, 32 bit ports\nTypes\n\nControl registers: receive device commands\nStatus registers: contains device’s internal status information\nInput registers: data is taken from the device\nOutput registers: data is written to transmit it to the device\n\n\nExample\n\nParallel Port has eight ports (each port: 8bits).\nData Log @base: 0x378\n\nboth entry &amp; exit log\n\n\nStatus Register @base+1: 0x379\nControl Register @base+2: 0x37a\n\n\n\nIRQ (Interrupt ReQuest) §\n\n\nI/O ports or Special memory areas can be insufficient to control the device\n\n\nPolling Inefficiency: interrogating the device status repeatedly\n\n\nObjective: 특정 event가 일어났을 때, hardware가 event가 일어났음을 알려줌\n\n\nTo make use..\n\nInterrupt Handlers must be implemented\nInterrupts must be requested before use and released after use.\nDevice Drivers must\n\nshare an interrupt or\nsynchronize with interrupts\n\n\n\n\n\nAccessing shared resources\n\nbetween an interrupt routine\n\n\n\nAccessing the hardware §\n1. Request Access to I/O Ports §\n\n__request_region\n__release_region\n\n// Shorthand\n#define request_region(start,n,name) __request_region(&amp;ioport_resource, (start), (n), (name), 0)\n#define release_region(start,n) __release_region(&amp;ioport_resource, (start), (n))\nExample §\n\nCOM1\n\nBase Address: 0x3F8\nhas 8 ports\n\n\n\nRequesting access §\n#include &lt;linux/ioport.h&gt;\n \n#define MY_BASEPORT 0x3F8\n#define MY_NR_PORTS 8\n \nif (!request_region(MY_BASEPORT, MY_NR_PORTS, &quot;com1&quot;)) {\n     /* handle error */\n     return -ENODEV;\n}\nReleasing access §\nrelease_region(MY_BASEPORT, MY_NR_PORTS);\nList Port Requests §\n$ sudo cat /proc/ioports\n0000-001f : dma1\n0020-0021 : pic1\n0040-005f : timer\n0060-006f : keyboard\n0070-0077 : rtc\n0080-008f : dma page reg\n00a0-00a1 : pic2\n00c0-00df : dma2\n00f0-00ff : fpu\n0170-0177 : ide1\n01f0-01f7 : ide0\n0376-0376 : ide1\n0378-037a : parport0\n037b-037f : parport0\n03c0-03df : vga+\n03f6-03f6 : ide0\n03f8-03ff : serial\n...\n\n2. Accessing I/O Ports (Kernel Space) §\nasm/io.h §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nsignaturecommentsunsigned inb(int port)reads one byte (8 bits) from portvoid outb(unsigned char byte, int port)writes one byte (8 bits) to portunsigned inw(int port)reads two bytes (16-bit) portsvoid outw(unsigned short word, int port)writes two bytes (16-bits) to portunsigned inl (int port)reads four bytes (32-bits) from portvoid outl(unsigned long word, int port)writes four bytes (32-bits) to port\n\nTo insert delay (in case I/O operations transferring data too fast which occurs problems), insert _p such as inb_p, outb_p, etc.\n\nExample §\n#include &lt;asm/io.h&gt;\n#define MY_BASEPORT 0x3F8\n \nunsigned char value = 0xFF;\noutb(value, MY_BASEPORT);\nvalue = inb(MY_BASEPORT);\n3. Accessing I/O ports (User Space) §\nsys/io.h §\n\nioperm\niopl Deprecated\n\nExample §\n#include &lt;sys/io.h&gt;\n#define MY_BASEPORT 0x3F8\n \n// Get &amp; Release permission for the first 3 ports of the serial port\n \n/* 1 to get permission */\nif (ioperm(MY_BASEPORT, 3, 1)) {\n     /* handle error */\n}\n \n/* 0 to release permission */\nif (ioperm(MY_BASEPORT, 3, 0)) {\n     /* handle error */\n}\nInterrupt Handling §\nRequesting an interrupt §\nrequest_irq &amp; free_irq §\n#include &lt;linux/interrupt.h&gt;\n \ntypedef irqreturn_t (*irq_handler_t)(int, void *);\n \nint request_irq(unsigned int irq_no, irq_handler_t handler,\n                unsigned long flags, const char *dev_name, void *dev_id);\n \nvoid free_irq(unsigned int irq_no, void *dev_id);\nhandler function is executed in interrupt context..\n\nwe can’t call blocking APIs(mutex_lock() or msleep())\navoid doing a lot of work &amp; use deferred work if needed\nread the device register to get the status of the device and acknowledge the interrupt\noperations that most of the time can be performed with non-blocking calls\n\nrequest_threaded_irq §\ndevice에서 interrupt 발생해도 non-blocking mode에서 device register 읽을 수 없는 상황 존재..\n이런 경우에 work-in-process action (ex. work queue, kernel thread)를 이용하여 device register에 접근해야 함.\nrequest_threaded_irq 이용하면 process-phase 혹은 interrupt context phase에서 interrupt handling 을 수행할 수 있음.\n\nhandler: interrupt context에서 수행할 function\nthread_fn: process context에서 수행할 function\n\n#include &lt;linux/interrupt.h&gt;\n \nint request_threaded_irq(unsigned int irq, irq_handler_t handler,\n                         irq_handler_t thread_fn,\n                         unsigned long flags, const char *name, void *dev);\nflags §\n\nIRQF_SHARED: interrupt can be shared with other devices.\n\nif not set, if there’s already a handler associated with the requested interrupt, the request for interrupt will fail\nall the associated interrupt handlers will be executed until the device that genet\n\n\nIRQF_ONESHOT:\n\nReference §\n\nrequests_irq\nfree_irq\nProcess Context + Interrupt Context + Context Switching\n\nImplementing an interrupt handler §\nInterrupt Handler Function Signature\nirqreturn_t (*handler)(int irq_no, void *dev_id);\nReference §\nLocking §\n\ninterrupt handler들은 interrupt context에서 실행되기 때문에 다음과 같은 실행 가능한 동작들이 제한된다.\n\nuser space memory 접근 불가\nblocking function 호출 불가\n\n\nspinlock 이용한 synchronization 까다롭고 deadlock 만들 수 있음 (spinlock used is already acquired by a process that has been interrupted by the running handler)\n하지만, spinlock 이용하는 경우 있음…\n\ninterrupt handler - process context 사이에서 데이터 공유\ninterrupt handler - bottom-half handler 사이에서 데이터 공유\n이런 경우에는 interrupt를 끄고 spinlock을 써야됨..\n\n\nDisabling Interrupts\n\nprocessor level에서 모든 interrupt 끄기.. faster &amp; preferred\ninterrupt controller level에서 특정 interrupt 끄기\n\n\n\nDisabling All Interrupts at Processor level §\n#include &lt;linux/spinlock.h&gt;\n \nvoid spin_lock_irqsave (spinlock_t * lock, unsigned long flags);\nvoid spin_unlock_irqrestore (spinlock_t * lock, unsigned long flags);\n \nvoid spin_lock_irq (spinlock_t * lock);\nvoid spin_unlock_irq (spinlock_t * lock);\n\n\nread_lock_irqsave()\n\n\nread_unlock_irqrestore()\n\n\nread_lock_irq()\n\n\nread_unlock_irq\n\n\nwrite_lock_irqsave()\n\n\nwrite_unlock_irqrestore()\n\n\nwrite_lock_irq()\n\n\nwrite_unlock_irq()\n\n\nDisabling Particular Interrupt at Interrupt Controller level §\n\ndisable_irq()\ndisable_irq_nosync(): async version\nenable_irq()\n\nInterrupt Statistics §"},"Linux/Kernel-Labs/05_Deferred-Work":{"title":"Deferred Work","links":[],"tags":["linux","kernel"],"content":"Objectives §\n\nUnderstanding deferred work\nImplementation of common tasks that uses deferred work\nUnderstanding the peculiarities of synchronization for deferred work\n\nBackground information §\nDeferred Work §\n\nDefinition: A class of kernel facilities that allows one to schedule code to be executed at a later timer\nCan run either in process context or in interruption context depending on the type of the deferred work.\nUsed to complement the interrupt handler functionality since interrupts have some important requirements &amp; limitations such as..\n\nThe execution time of the interrupt handler must be as small as possible\nIn interrupt context we can not use blocking calls\n\n\nAlso called as bottom-half since its purpose is to execute the rest of the actions from an interrupt handler top-half.\nTypical Operations\n\nInitialization\n\nEach type is described by a structure whose fields will have to be initialized.\nThe handler to be scheduled is also set at this time.\n\n\nScheduling\n\nSchedules the execution of the handler ASAP.\n\n\nMasking / Canceling\n\nDisables the execution of the handler.\nThis action can be either synchronous or asynchronous\nsynchronous action: guarantees that the handler will not run afterh the completion of canceling\n\n\n\n\n\nSoftirqs §\n "},"Linux/Kernel-Labs/index":{"title":"Kernel Labs","links":[],"tags":[],"content":""},"Linux/Linux-Commands/Linux-BIOS":{"title":"Linux BIOS","links":[],"tags":["linux"],"content":"BIOS 진입법\nsudo systemctl reboot --firmware-setup\n"},"Linux/Linux-Commands/Upgrade-Debian":{"title":"Upgrade Debian","links":[],"tags":["linux"],"content":"Installation §\nsudo apt update\nsudo apt upgrade -y\nsudo reboot\nsudo sed -i &#039;s/bullseye/bookworm/g&#039; /etc/apt/sources.list\nsudo apt upgrade --without-new-pkgs\nsudo apt full-upgrade\nTroubleshooting §\nLinux kernel build error: return code 11 dkms error §\nsudo dpkg --purge &lt;*-dkms&gt; &amp;&amp; sudo apt -f install\n# should find what package is occurring error\n# read logs\n# my case, /var/libs/dkms/kernel-mft-dkms/4.18.0/build/make.log\n# sudo dpkg --purge kernel-mft-dkms &amp;&amp; sudo apt -f install resolved the error"},"Linux/Linux-Commands/index":{"title":"Linux Commands","links":[],"tags":[],"content":""},"Linux/Linux-Commands/rsync":{"title":"rsync","links":[],"tags":["linux"],"content":"rsync &lt;options&gt; &lt;source&gt; &lt;destination&gt;\n"},"Linux/index":{"title":"Linux","links":[],"tags":[],"content":""},"Projects/Cookie/0314_아이디어발표":{"title":"3/14 아이디어 발표","links":[],"tags":["keynote"],"content":""},"Projects/Cookie/0328_발표":{"title":"3/28 5주차 발표","links":[],"tags":["keynote"],"content":""},"Projects/Cookie/0411_발표":{"title":"4/11 7주차 발표","links":[],"tags":["keynote"],"content":""},"Projects/Cookie/0425_발표":{"title":"4/25 9주차 발표","links":[],"tags":["keynote"],"content":""},"Projects/Cookie/0509_발표":{"title":"5/9 13주차 발표","links":[],"tags":["keynote"],"content":""},"Projects/Cookie/0523_발표":{"title":"5/23 15주차 발표","links":[],"tags":["keynote"],"content":""},"Projects/Cookie/0613_발표":{"title":"6/13 18주차 발표","links":[],"tags":["keynote"],"content":""},"Projects/Cookie/0620_최종발표":{"title":"6/20 1학기 최종발표","links":[],"tags":["keynote"],"content":""},"Projects/Cookie/0911_소개발표":{"title":"9/11 2학기 소개발표","links":[],"tags":["keynote"],"content":""},"Projects/Cookie/0925_발표":{"title":"9/25 4주차 발표","links":[],"tags":["keynote"],"content":""},"Projects/Cookie/1023_발표":{"title":"10/23 8주차 발표","links":[],"tags":["keynote"],"content":""},"Projects/Cookie/1106_발표":{"title":"11/6 10주차 발표","links":[],"tags":["keynote"],"content":""},"Projects/Cookie/1120_발표":{"title":"11/20 12주차 발표","links":[],"tags":["keynote"],"content":""},"Projects/Cookie/1211_발표":{"title":"12/11 14주차 발표","links":[],"tags":["keynote"],"content":""},"Projects/Cookie/1218_최종발표":{"title":"12/18 2학기 최종발표","links":[],"tags":["keynote"],"content":""},"Projects/Cookie/index":{"title":"Cookie","links":[],"tags":["flutter","express"],"content":"\n\nRepository is currently private due to API keys.\n\n\nconst setRepoTheme = (theme) =&gt; {\n\tconst elems = document.querySelectorAll(&#039;.repo-card&#039;)\n\tfor (const elem of elems) {\n\t\tif (theme === &#039;dark&#039;)\n\t\t\telem.setAttribute(&#039;data-theme&#039;, &#039;dark-theme&#039;)\n\t\telse\n\t\t\telem.setAttribute(&#039;data-theme&#039;, &#039;light-default&#039;)\n\t}\n\twindow.tarptaeya.reloadRepoCards()\n}\nsetRepoTheme(document.documentElement.getAttribute(&#039;saved-theme&#039;))\ndocument.querySelector(&#039;#darkmode-toggle&#039;).addEventListener(&#039;change&#039;, (e) =&gt; setRepoTheme(e.target.checked ? &#039;dark&#039; : &#039;light&#039;))\n"},"Projects/Doge_Driver":{"title":"Doge Driver","links":[],"tags":[],"content":"\n\n\n\n\nconst setRepoTheme = (theme) =&gt; {\n\tconst elems = document.querySelectorAll(&#039;.repo-card&#039;)\n\tfor (const elem of elems) {\n\t\tif (theme === &#039;dark&#039;)\n\t\t\telem.setAttribute(&#039;data-theme&#039;, &#039;dark-theme&#039;)\n\t\telse\n\t\t\telem.setAttribute(&#039;data-theme&#039;, &#039;light-default&#039;)\n\t}\n\twindow.tarptaeya.reloadRepoCards()\n}\nsetRepoTheme(document.documentElement.getAttribute(&#039;saved-theme&#039;))\ndocument.querySelector(&#039;#darkmode-toggle&#039;).addEventListener(&#039;change&#039;, (e) =&gt; setRepoTheme(e.target.checked ? &#039;dark&#039; : &#039;light&#039;))\n"},"Projects/Elevator-Controller":{"title":"엘레베이터 컨트롤러","links":[],"tags":["Verilog","DigitalSystem","assignment"],"content":"\nSpecifications §\n\nThe elevator control system consists of an elevator car and a controller.\n\nYou should design 3 Verilog modules including a test bench.\nAll signal names in the codes should follow the below diagram.\n\n\nThe elevator operates in a 5th floor building.\n\nExample specification\n\nThe elevator is currently on the 2nd floor.\nA user on the 4th floor pushes the down button.\nThe elevator moves up to the 4th floor, and then the door opens.\nThe user in the elevator pushes the 1st floor button.\nThe door closes, and then move down to 1st floor, and finally opens.\n\n\nMaximally 2 persons use the elevator control system.\n\nFor example, during the above procedure 3, if another user on the 5th floor pushes the down button, then the elevator moves up to 5th floor, and then 4th floor.\n\n\nIt takes one second for the elevator to move one floor.\nIt takes one second for the door to open and close, respectively.\n\nAbstract §\n이번 과제에서는 최대 2인의 사용자 입력에 대해서 엘레베이터가 방문해야 할 층을 스케줄링하고, 엘레베이터가 이동하는 로직을 구현해야 한다. 과제에서 주어진 모듈간의 큰 틀은 다음과 같았다.\n\n이를 세부적으로 구현하기 위하여 이와 같은 구조로 실제 모듈들을 설계하였다.\n\nTarget_Controller는 엘레베이터를 목표한 층으로 이동시켜주는 Controller의 sub-module이다. 또, 동일한 Input으로 사용자의 입력을 저장하기 위해서 set_clk를 이용하여 posedge가 나타날 때에만 레지스터에 값을 저장하도록 제작하였다. 각각의 층수들은 3비트 unsigned binary로 나타내었다.\nController 모듈 §\nController 모듈 State 정의 §\n개발의 편의를 위하여 하나의 state에 대해 두가지 변수를 이용하였으며, 각각 done과 on_board이다. Done은 해당 비트의 사용자가 도착하였는지에 대한 정보이며, on_board는 해당 비트의 사용자가 현재 엘레베이터를 탑승하였는지에 대한 정보이다. 즉 예를 들어, done=00, on_board=11의 경우 2명의 사용자 모두 아직 목적지에 도착하지 못하였으며, 2명의 사용자 모두 엘레베이터를 탑승하고 있는 상황에 대한 state이다. 또 다른 예로 done=01, on_board=00의 경우 #2 사용자가 아직 목적지에 도착하지 못하였으며, 엘레베이터에 탑승하지도 못한 state임을 나타낸다. 이러한 notation을 토대로 state를 구상하면 다음과 같은 state들이 나올 수 있다.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDoneOn_board설명1100사용자 입력이 없는 경우의 state10001번 사용자가 아직 탑승하지 않았고 엘레베이터를 기다리고 있는 state + 한명의 사용자 입력을 추가적으로 받을 수 있는 상태10011번 사용자가 엘레베이터에 탑승하여 도착층으로 이동하는 state+ 한명의 사용자 입력을 추가적으로 받을 수 있는 상태01002번 사용자가 아직 탑승하지 않았고 엘레베이터를 기다리고 있는 state+ 한명의 사용자 입력을 추가적으로 받을 수 있는 상태01102번 사용자가 엘레베이터에 탑승하여 도착층으로 이동하는 state+ 한명의 사용자 입력을 추가적으로 받을 수 있는 상태00001번 사용자와 2번 사용자가 둘 다 입력을 하였고, 둘 다 엘레베이터를 탑승하지 못하고 대기중인 state00011번 사용자와 2번 사용자가 둘 다 입력을 하였고, 1번 사용자는 엘레베이터에 탑승하여 자신의 도착층으로 이동중이고, 2번 사용자는 아직 엘레베이터에 탑승하지 않고 기다리고 있는 state00101번 사용자와 2번 사용자가 둘 다 입력을 하였고, 2번 사용자는 엘레베이터에 탑승하여 자신의 도착층으로 이동중이고, 1번 사용자는 아직 엘레베이터에 탑승하지 않고 기다리고 있는 state00111번 사용자와 2번 사용자가 둘 다 입력을 하였고, 둘 다 엘레베이터에 탑승하여 자신의 도착층으로 이동중인 state1101탑승한 사용자가 모두 도착층에 도착하였는데 엘레베이터에 탑승하고 있을 경우는 존재할 수 없다.1110탑승한 사용자가 모두 도착층에 도착하였는데 엘레베이터에 탑승하고 있을 경우는 존재할 수 없다.1111탑승한 사용자가 모두 도착층에 도착하였는데 엘레베이터에 탑승하고 있을 경우는 존재할 수 없다.1010탑승한 사용자가 모두 도착층에 도착하였는데 엘레베이터에 탑승하고 있을 경우는 존재할 수 없다.1011탑승한 사용자가 모두 도착층에 도착하였는데 엘레베이터에 탑승하고 있을 경우는 존재할 수 없다.0101탑승한 사용자가 모두 도착층에 도착하였는데 엘레베이터에 탑승하고 있을 경우는 존재할 수 없다.0111탑승한 사용자가 모두 도착층에 도착하였는데 엘레베이터에 탑승하고 있을 경우는 존재할 수 없다.\n이를 토대로 State Diagram을 그려보면 다음과 같이 나타낼 수 있다.\n\n위의 2개의 bit가 done, 아래 2개의 bit가 on_board를 나타내며, transition하는 각각의 조건에 대해서는 색깔로 구분하였다. 또, 간단하게 표현하기 위해서 사용자가 입력하였을 때 state이 transition하는 것에 대해서는 표기하지 않았으며, 그 외 다른 조건들에 대해서는 자기 자신의 state을 유지하도록 하였다. 해당 state transition 만을 코드로 간략하게 표기하면 다음과 같다.\n\nController 모듈은 다음과 같이 크게 3가지 부분으로 구성된다.\n입력단 §\n입력단의 경우 최대 2명의 사용자가 동시에 이용할 수 있으므로, 출발층, 도착층, 방향 세가지 입력을 받아 이를 저장해두는 역할을 한다. State를 입력받아 저장하기 위해서 set_clk라는 클락을 정의하였으며, 해당 input에서 posedge가 있을 때에 대해서만 유효한 input으로 간주한다. Posedge 입력이 들어올 때마다 input을 받아 저장하는데, 이때 출발층과 도착층이 같거나, 올라가는 입력인데 출발층보다 도착층이 작거나 거꾸로 내려가는 입력인데 출발층이 도착층보다 클 경우에 대해서는 시뮬레이터에 경고 메시지를 발생시키고 해당 input을 무시하였다.\n올바른 입력이 들어왔을 때 done state를 확인하여 만약 00일 경우, 즉 2명의 사용자 모두 아직 도착하지 못했을 경우에 대해서는 엘레베이터가 아직 모든 일을 처리하지 못하였기 때문에 경고 메세지를 발생시키고 해당 Input을 무시하였다. 만약 done state의 두 비트중 어떤 하나라도 1일 경우 해당하는 레지스터에 사용자의 Input을 저장해 두었으며, done 의 두 비트중 1이였던 비트를 0으로 바꾸어 해당 동작을 수행해야 하는 상태로 state transition을 수행하였다.\n타겟층 선택단 (output logic) §\n최대 2명의 사용자에 대해서 출발층과 도착층을 비교하여 현재 이동해야 할 타겟층을 선택하는 역할을 한다. 즉 현재 상태에 대해서 이동해야 할 타겟 층수를 결정하는 단계이다. 이를 결정하는 방법은 다음의 표와 같다.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDoneOn_board출력110010001번 사용자의 출발층10011번 사용자의 도착층01002번 사용자의 출발층01102번 사용자의 도착층0000상황에 따라 판단 1번, 2번 사용자 모두 위로 갈 경우: 1번 사용자의 출발층과 2번 사용자의 출발층 중 더 작은 층수1번, 2번 사용자 모두 아래로 갈 경우: 1 번 사용자의 출발층과 2번 사용자의 출발층 중 더 큰 층수1번, 2번 사용자가 서로 다른 방향으로 갈 경우: 1 번 사용자의 출발층(이 경우 임의의 사용자 한명에 대해 먼저 처리하면 다른 State로 transition 되므로 1번층을 우선적으로 선택하였다. )0001상황에 따라 판단1번, 2번 사용자 모두 위로 갈 경우: 현재 1번 사용자만 탑승해 있으므로, 1번 사용자의 도착층과 2번 사용자의 출발층을 비교하여 1번 사용자의 도착층에 가는 중에 2번 사용자의 출발층을 거쳐가면, 2번 사용자의 출발층에 가야하고, 그렇지 않을 경우 1번 사용자의 도착층에 가야한다. 따라서 1** 번 사용자의 도착층과 **** 2 번 사용자의 출발층 중 더 작은 층수1번, 2번 사용자 모두 아래로 갈 경우: 마찬가지로, 이 경우에는 1 번 사용자의 도착층과 **** 2 번 사용자의 출발층 중 더 큰 층수 를먼저 방문해야 한다.1번, 2번 사용자가 서로 다른 방향으로 갈 경우: 현재 1번 사용자가 탑승해 있으므로, 먼저 1번 사용자를 도착층으로 데려가야 한다. 따라서 1 번 사용자의 도착층**0010상황에 따라 판단 (Done 00, On_board 01의 상황과 유사) 1번, 2번 사용자 모두 위로 갈 경우: 현재 2번 사용자만 탑승해 있으므로, 2번 사용자의 도착층과 1번 사용자의 출발층을 비교하여 2번 사용자의 도착층에 가는 사이에 1번 사용자의 출발층을 거쳐간다면 1번 사용자의 출발층을 목적지로 삼아야 하고, 그렇지 않을 경우 2번 사용자의 도착층에 도착해야 한다. 따라서, 1** 번 사용자의 출발층과 **** 2 번 사용자의 도착층 중 더 작은 층수1번, 2번 사용자 모두 아래로 갈 경우: 마찬가지로, 이 경우에는 1 번 사용자의 출발층과 **** 2 번 사용자의 도착층 중 더 높은 층수 를 먼저 방문해야 한다.1번, 2번 사용자가 서로 다른 방향으로 갈 경우: 현재 2번 사용자가 탑승해 있으므로, 먼저 2번 사용자를 도착층으로 데려가야 한다. 따라서 2 번 사용자의 도착층**0011상황에 따라 판단1번, 2번 사용자 모두 위로 갈 경우: 1** 번 사용자의 도착층과 **** 2 **번 사용자의 도착층 중 더 작은 층수1번, 2번 사용자 모두 아래로 갈 경우: 1 번 사용자의 도착층과 2번 사용자의 도착층 중 더 큰 층수1번, 2번 사용자가 서로 다른 방향으로 갈 경우: 서로 다른 방향으로 가는데 동시에 타고 있을 경우는 존재할 수 없다. 따라서 이전의 출력을 유지한다. 1101탑승한 사용자가 모두 도착층에 도착하였는데 엘레베이터에 탑승하고 있을 경우는 존재할 수 없다. 따라서 이전의 출력을 유지한다.1110탑승한 사용자가 모두 도착층에 도착하였는데 엘레베이터에 탑승하고 있을 경우는 존재할 수 없다. 따라서 이전의 출력을 유지한다.1111탑승한 사용자가 모두 도착층에 도착하였는데 엘레베이터에 탑승하고 있을 경우는 존재할 수 없다. 따라서 이전의 출력을 유지한다.1010탑승한 사용자가 모두 도착층에 도착하였는데 엘레베이터에 탑승하고 있을 경우는 존재할 수 없다. 따라서 이전의 출력을 유지한다.1011탑승한 사용자가 모두 도착층에 도착하였는데 엘레베이터에 탑승하고 있을 경우는 존재할 수 없다. 따라서 이전의 출력을 유지한다.0101탑승한 사용자가 모두 도착층에 도착하였는데 엘레베이터에 탑승하고 있을 경우는 존재할 수 없다. 따라서 이전의 출력을 유지한다.0111탑승한 사용자가 모두 도착층에 도착하였는데 엘레베이터에 탑승하고 있을 경우는 존재할 수 없다. 따라서 이전의 출력을 유지한다.\n\n이를 작성한 코드는 위와 같다.\n타겟층 이동단 §\n타겟층이 선택되었을 때, 엘레베이터의 현재 층수와 비교하여 해당 타겟층으로 이동하는 역할을 한다. 해당 부분은 target_controller 모듈로 따로 선언하였다. 해당 모듈은 타겟층과 현재 엘레베이터의 상태를 비교해서 엘리베이터에 올라가는 명령을 내릴지, 내려가는 명령을 내릴지, 문을 열지 닫을지에 대한 정보를 Elevator 모듈에 전달하는 중간 모듈이다. 엘레베이터가 각 동작을 수행할 때에 1초씩 걸림을 고려하여 지연을 주었다.\nElevator 모듈 §\nElevator 모듈의 경우 총 10가지 State로 나눈 State Machine을 구상하여 제작하였다. 회로의 안정성을 위해서 그레이 코드를 이용하여 상태들을 나타내었으며, 각각의 상태들에 대한 상태머신은 다음과 같다.\n\n상태에 대한 Notation은 1Fc는 floor1_closed, 2Fc는 floor2_closed, 3Fo는 floor3_closed 등등과 같으며, 3가지 input (혹은 DU를 하나의 버스로 생각한다면 2가지 input, 실제 코드에서는 이와 같이 구현되어 있다.) 은 각각 O, D, U로, 각각 Open, Down, Up을 의미한다. 즉, D’U의 경우 내려가는 것에 대한 입력, DU’의 경우 올라가는 것에 대한 입력, DU 혹은 D’U’은 IDLE상태로 있는 것에 대한 입력이며, 올라가거나 내려갈때는 항상 문이 닫힌 상태로, IDLE 상태일때는 문이 열리고 닫힌 상태 모두 가능하다.\n각각의 층에서 문이 닫혀있는 상태일 때, 올라가는 입력 (O’D’U)이 들어오면 위층의 닫힌 상태로 상태를 바꾸었으며, 반대로 내려가는 입력 (O’DU’)이 입력된다면 아랫층의 닫힌 상태로 상태를 바꾸었다. 또, 문이 열리는 입력 (O)이 입력된다면 해당 층에서 문이 열린 상태로 상태를 바꾸었으며, 문이 열린 상태에서 문을 닫는 입력 (O’)을 입력하였을 때에는 해당 층의 문이 닫힌 상태로 상태를 바꾸도록 하였다. 1층에서 닫힌 상태로 있을 경우, 만약 O’DU’ (내려가는 입력)과 같이 불가능한 입력이 들어온다면 해당 입력을 수행하지 않고 같은 상태로 유지하도록 하였으며, 이는 5층에서 O’D’U (올라가는 입력)에서도 마찬가지로 적용하였다.\n위의 상태머신에서 그레이 코드화 시켜 예기치 못한 오류를 최소화하도록 각각의 상태들을 할당하였다. 즉, 각각의 상태에 대한 코드는 다음과 같다.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfloor1_closed0001floor1_open1001floor2_closed0011floor2_open1011floor3_closed0010floor3_open1010floor4_closed0110floor4_open1110floor5_closed0111floor5_open1111\n즉, MSB는 문이 열려있는지 닫혀있는지에 대한 상태이며, 나머지 3비트는 각각의 층에 대한 그레이 코드이다. 위의 상태머신 다이어그램을 참조하면 두가지 이상의 비트가 동시에 바뀌는 경우는 없음을 확인할 수 있다.\n최종적으로는, 각 상태를 문이 열렸는지 혹은 몇층인지로 변환해주는 부분이 필요하여, 그레이 코드를 부호가 없는 binary로 xor 연산을 이용하여 변환해 주었으며, 문의 열림/닫힘 상태는 MSB 비트를 출력하여 각각의 상태에 대해서 변환한 값을 출력해주었다.\n실제 코드상에서 이를 구현할 때에는 문이 열리고 닫힐 때 1초, 엘레베이터가 층을 이동할 때 1초의 delay가 있으므로 클락을 이용하여 다른 상태로 전환될 때 delay를 주어 이를 가상으로 구현하였다.\n테스트벤치 §\n엘레베이터는 초기상태로 1층에서 문을 닫은 상태로 정지하고 있다고 가정하였다. 이는 엘레베이터 모듈에 정의되어 있다.\n예제 1 §\n해당 테스트벤치는 다음과 같은 입력을 가진다.\n\n초기상태 5초딜레이\n4층→2층 5초 딜레이\n5층→3층 14초 딜레이 (엘레베이터가 이전 작업들을 마저 수행하기 위해서 기다리는 delay로, 이전 수행중인 작업을 완료하기 위해서는 최소 11초의 딜레이가 필요하다. )\n4층→3층\n끝날때까지 충분히 딜레이\n\n\n의도하였던 대로, 1층에 있는 엘레베이터가 4층의 사용자를 데려가기 위해 4층으로 이동중에 5층에서 내려가는 입력이 들어와 5층을 우선적으로 방문하여 두명의 사용자를 같이 내려갈 수 있도록 target_floor_input이 바뀌었고, 이에 따라 엘레베이터도 5층을 우선적으로 방문하여 문을 열어 2번 사용자를 태운다. 그리고 순차적으로 4층에 방문하여 1번 사용자도 태운 뒤, 2번 사용자와 1번 사용자 각자의 목적지인 3층과 2층을 순차적으로 방문하여 사용자가 하차할 수 있음을 확인하였다. 또, 1번 사용자의 목적지에 도달한 이후에도 새로운 사용자의 input을 수행하기 위해서 4층으로 target_floor_input이 세팅되어 엘레베이터가 이동하였음을 확인하였다. 그리고 마지막 사용자까지 최종 도착층인 2층에 내려주고 idle 상태로 기다림을 확인할 수 있다.\n예제 2 §\n해당 테스트벤치는 다음과 같은 입력을 가진다.\n\n2층→5층 5초 딜레이\n3층→4층 5초 딜레이\n5초 딜레이 (엘레베이터가 이전 작업들을 마저 수행하기 위해서 기다리는 delay로, 이전 수행중인 작업을 완료하기 위해서는 최소 4초의 딜레이가 필요하다. )\n4층→3층\n끝날때까지 충분히 딜레이\n\n\n의도하였던 대로, 1층에서 4층에 있는 첫번째 사용자를 태우기 위해 올라가던 중에 5층에 있는 두번째 사용자가 입력하였기 때문에, 효율을 위해서 5층을 먼저 방문하여 두번째 사용자를 태운 뒤, 4층을 방문하여 첫번째 사용자를 태우고, 목표한 3층과 2층으로 순차적으로 방문한다.\n\n\n\n\nconst setRepoTheme = (theme) =&gt; {\n\tconst elems = document.querySelectorAll(&#039;.repo-card&#039;)\n\tfor (const elem of elems) {\n\t\tif (theme === &#039;dark&#039;)\n\t\t\telem.setAttribute(&#039;data-theme&#039;, &#039;dark-theme&#039;)\n\t\telse\n\t\t\telem.setAttribute(&#039;data-theme&#039;, &#039;light-default&#039;)\n\t}\n\twindow.tarptaeya.reloadRepoCards()\n}\nsetRepoTheme(document.documentElement.getAttribute(&#039;saved-theme&#039;))\ndocument.querySelector(&#039;#darkmode-toggle&#039;).addEventListener(&#039;change&#039;, (e) =&gt; setRepoTheme(e.target.checked ? &#039;dark&#039; : &#039;light&#039;))\n"},"Projects/OS-Assignments/index":{"title":"OS Assignments","links":[],"tags":["os","assignment","C"],"content":""},"Projects/OS-Assignments/pa0":{"title":"PA0: Warming up C programming","links":[],"tags":["os","assignment","C"],"content":"Simple Linux List Manipulation &amp; C Warming Up Project\nhttps://github.com/parkjbdev/SCE213_OS/tree/os-pa0"},"Projects/OS-Assignments/pa1":{"title":"PA1: My Amazing Shell","links":[],"tags":["os","assignment","C"],"content":"https://github.com/parkjbdev/SCE213_OS/tree/os-pa1\nLogic §\nmash.c §\nflowchart LR\n  initialize --&gt; while --&gt; get_command --command--&gt; parse_command -- nr_tokens, tokens --&gt; run_command --&gt; free_command_tokens --&gt; if_terminate\n  if_terminate{{run_command != 0}} --true--&gt; while\n  if_terminate --false--&gt; finalize\n\nmash.c에서는 command를 실행하기 전에 command를 입력받고, 이를 parser.c에 정의된 parse_command 함수를 통해 공백을 기준으로 command를 토큰화하여 run_command에 전달하여 command를 실행한 뒤, 메모리에서 token들을 해제하는 과정을 거친다. 위 flowchart에 그 과정과 인자들의 전달을 모식화해두었다.\npa1.c §\nflowchart TD\nSTART --&gt; strcmp{{&quot;tokens[0]&quot;}}\nstrcmp --exit--&gt; exit[return 0]\nstrcmp --cd--&gt; cd[builtin_cd]\nstrcmp --alias--&gt; alias[builtin_alias]\nstrcmp --else--&gt; replace_alias --&gt; execute\n\npa1.c 에서는 우선 첫번째 입력된 토큰 tokens[0]가 builtin function인지 판단하여, builtin function일 경우 nr_tokens에 따라 올바른 동작을 수행할 수 있도록 하였다. builtin function이 아닐 경우, 즉, 명령어를 실행해야 될 경우에는 우선 alias로 등록된 token이 있는지 확인하여 이를 대체하는 과정을 거친 후 execute함수를 통해 실행하게 된다. 위는 간단한 flowchart이다. 각각의 함수의 동작과정에 대해서는 아래에 기술하였다.\nFeatures §\nBuiltin Command - cd §\ncd 기능은 현재의 working directory를 바꾸는 명령어로, builtin_cd 함수로 실행되는데, 인자로 변경할 디렉토리의 주소 dir이 입력되면, 이에 맞는 곳으로 이동한다.\n전달된 인자가 ~일 경우 getenv 를 이용하여 환경변수 목록중에서 $HOME 환경변수를 찾아 home directory 로 이동할 수 있도록 하였다. 또, cd만 입력되었을 때 역시 home directory로 이동해야 하는데, 이는 run_command 함수에서 전달된 인자가 1개일 때에는 builtin_cd(&quot;~&quot;)가 실행되도록 하여 의도한 동작을 수행할 수 있도록 하였다.\ncd 명령어가 성공적으로 실행되었을 때에 builtin_cd 함수는 1을 반환하고, 그렇지 않을 경우 perror를 통한 에러메세지와 함께 -1을 반환하도록 하였다.\n추가구현 - 이전 directory 이동: - §\n추가적으로 전달된 인자가 -일 경우 이전 디렉토리를 저장해두는 기능을 구현하였다. 이를 위해 디렉토리를 이동할 때마다, 환경변수에 등록된 $PWD값과 $OLDPWD값을 setenv를 통해 다시 설정하여 주었다.\nLessons Learned §\ncd 기능을 구현하며 환경변수를 읽고 쓰는 getenv, setenv 함수, current working directory를 읽고 변경하는 getcwd, chdir 함수를 알게되었다.\nBuiltin Command - alias §\nalias 기능은 기존에 run_command로 입력된 tokens 중에 alias로 등록되어 있는 token들을 매치되는 token들로 대체하는 방식으로 기능을 구현하였다.\n이를 구현하기 위해서 하나의 alias에 대한 정보를 담는 구조체 Alias 를 정의하였으며, 해당 구조체의 member로, 대체될 문자열 alias, 해당 alias에 대해 대체시켜야 할 토큰들의 배열 tokens, tokens 배열의 길이를 저장하는 nr_tokens를 정의하였다. 새로운 alias를 동적할당하거나 메모리에서 해제할 때, 편의를 위해 new_alias, delete_alias 함수를 정의하여 이용하였다.\n또, 여러 alias 정보들을 저장하는 Alias의 배열 Alias **aliases 과 총 alias들의 개수 alias_cnt를 정의하였다.\n이를 간단한 다이어그램으로 나타내면 다음과 같다.\nclassDiagram\n  class Alias {\n    char* alias\n    int nr_tokens\n    char **tokens\n    new_alias()\n    delete_alias()\n    print_alias()\n  }\n\n  class Aliases {\n    int alias_cnt\n    Alias **aliases\n    builtin_alias_add()\n    builtin_alias_print()\n  }\n\n\n새로운 alias 추가과정 - builtin_alias_add §\n새로운 alias를 추가하는 일련의 과정은 다음과 같다.\nflowchart LR\n  builtin_alias_add --&gt; found\n  found{find_alias}\n  found -- not found --&gt; increase_alias_cnt[alias_cnt++] --&gt; realloc_aliases[realloc aliases] --&gt; add_alias[add new alias]\n  found -- found --&gt; replace_alias[replace tokens and nr_tokens]\n\n즉, alias를 추가하기 전에, find_alias 함수를 통해 aliases 배열에 기존에 등록된 같은 이름의 alias가 존재하는지 확인한 후, 같은 alias가 존재할 경우 이를 새로운 tokens와 nr_tokens로 대체하고, 기존에 같은 alias가 존재하지 않을 경우 새로운 alias를 추가하기 위해 aliases 배열을 alias_cnt+1 만큼 재할당해주어 새로운 alias를 등록해주는 과정을 거친다.\nalias 출력 - builtin_alias_print §\nbuiltin_alias_print 함수는 초기에는 모든 alias들을 출력하는 함수로 만들었으나, 개별 alias에 대해서 출력할 수 있도록 개선하였다.\n이를 위해 run_command에서 alias만 입력되어 token이 1개 입력된 경우, alias와 함깨 token이 2개 입력된 경우, 즉 alias ll과 같은 경우를 나누어 builtin_alias_add에 인자로 전달하였다.\n해당 함수에 NULL값이 들어올 경우, 모든 alias들을 출력하도록 하였고, 문자열이 들어올 경우 해당하는 alias를 find_alias를 통해 찾아서 출력하도록 하였다.\nalias replacement §\nbuiltin commands가 아닌 경우, execute을 통하여 command를 실행하기 전에, tokens를 순회하며 alias로 대체할 token이 있는지 확인하는 과정을 거친다. alias로 대체할 token이 존재한다면, 이를 대체하기 위해서 tokens[] 배열의 뒷부분을 alias의 token 개수만큼 미루는 작업을 진행한다.\n그리고 alias가 있던 index부터 미뤄진 만큼의 index에 alias token들을 넣는과정을 진행한다.\n최종적으로, aliasing 된 token들의 aliasing을 방지하기 위해 for loop을 순회하는 iterator i를 밀어낸 인덱스만큼 증가시켜 주었다. (ex. alias hello hi hello; echo hello world 의 실행결과는 hi hello world 여야 함, re-aliasing을 할 경우 무한히 긴 문자열이 생성됨)\n메모리 해제 §\n최종적으로 쉘을 terminate하기 전에 동적할당한 aliases의 개별 element와 aliases을 finalize 함수에서 해제해주었다.\nLessons Learned §\nalias 기능을 구현하며 메모리를 동적으로 할당하고 해제하는 과정을 통해 포인터와 이를 활용한 동적길이를 가진 배열에 대한 이해도를 향상시킬 수 있었다.\n특히, 문자열을 복사할 때, 기존에는 malloc을 통해 문자열을 저장하는 공간을 동적으로 만들고, 여기에 strcpy를 통해 복사하고는 하였는데, 이를 한번에 해주는 strdup이라는 유용한 함수를 알게되었다.\nExecution &amp; Pipe Implementation - execute §\n새로운 프로세스의 실행과 pipelining 부분의 logic에서 겹치는 부분이 발생하여 같은 section으로 포함한다.\n우선 execute을 실행하기 전에, tokens와 nr_tokens를 입력받아 이를 파이프라인 기호 | 단위로 나누어 command 단위로 토큰들을 분리시켰다.\n해당 과정은 parse_commands에서 수행된다. 명령어 단위로 분리된 토큰들을 저장하는 구조체 Command 를 정의하였으며, 여러 명령어들에 대한 list 와 명령어의 갯수 nr_commands 가 정의된 구조체 Commands 를 정의하였다. parse_commands  의 결과로 commands를 받아, commands-&gt;list[i]-&gt;tokens 단위별로 exec_command 에서 execvp 를 통해 실행하게 된다.\nExecution §\nPipelining이 없는 execution의 경우 이전에 pipeline을 구현하지 않은 상태인 50783ff4 커밋의 170라인 또는, 최종 커밋의 execution 함수의 마지막 fork이후 과정에서 이중으로 감싸진 if 문을 제외하고 코드를 참조하면 된다.\n즉, 프로그램이 실행되는 전체적인 과정은 fork를 진행하여 프로세스를 복사한 뒤, child process에서는 execvp함수를 호출하여 프로세스를 실행시키고, exit하는 과정을 거치고, parent process에서는 child process가 exit되는 것을 wait 함수를 통해 대기한다.\n그 과정을 flowchart로 표현하면 아래와 같다.\nflowchart LR\n  START --&gt;\n  last_fork{{pid=fork}}\n  last_fork --pid&lt;0--&gt; fork_error[fork_failed]\n  last_fork --pid==0--&gt; child[Child]\n  child --&gt; execute --&gt; exit\n  last_fork --pid&gt;0--&gt; par[Parent] --&gt; wait\n  wait-.-exit\n  wait --&gt; RETURN\n\nPipeLining §\nflowchart TD\nSTART --&gt;\nparse_commands --&gt; pipe --&gt; is_last_command{{no pipeline?}} --false--&gt;for_commands\nis_last_command--true--&gt;last_command\n\nfor_fork_par_close_write --&gt; last_command --&gt; last_fork{{pid=fork}}\nlast_fork --pid&lt;0--&gt; fork_error[fork_failed]\nlast_fork --pid==0--&gt; child[Child]\nchild --&gt; were_pipelines{{pipeline exists?}}\nwere_pipelines --false--&gt;execute--&gt;exit\nwere_pipelines --true--&gt;child_dup_read\nchild_dup_read[&quot;dup2 pipe_fd[0] as STDIN&quot;] --&gt; close_read[close read end of pipe] --&gt; execute\nlast_fork --pid&gt;0--&gt; par[Parent] --&gt; wait\nwait-.-exit\nwait --&gt; RETURN\n\n\nsubgraph for commands except last one\n  direction TB\n  for_commands[for commands except last one]--&gt;for_fork{{pid=fork}}\n  for_fork --pid&lt;0 --&gt; for_fork_error[fork failed]\n  for_fork --pid==0--&gt; for_fork_child[Child] --&gt; is_first_command\n  for_fork --pid&gt;0--&gt; for_fork_par[Parent] --&gt; for_fork_par_wait[wait] --&gt; for_fork_par_close_write[close write end of pipe] --&gt; for_commands\n  for_exit -.- for_fork_par_wait\n\n  subgraph child_process\n    direction TB\n    is_first_command{{is it first command?}} --true--&gt; for_child_dup_read[&quot;dup2 pipe_fd[0] as STDIN&quot;]\n    --&gt;for_child_dup_write\n    is_first_command --false--&gt;for_child_dup_write[&quot;dup2 pipe_fd[1] as STDOUT&quot;]--&gt;close_child_read[close read end of the pipe]--&gt;for_execute[execute] --&gt; for_exit[exit]\n    end\n  end\n\n\nTestCase에는 파이프라이닝이 하나인 케이스만 존재하는것 같았으나, Multi Pipeline을 지원하기 위해 command 단위별로 for loop을 순회하며 프로세스를 실행시켰다. 그 과정을 flowchart로 그려보았으나, 과정에 비해 더 복잡하게 보이므로, 첨부하지는 않았다. (gitlab REPORT.md 참조)\n전체적인 흐름은 앞에서 언급한 Execution 과정과 동일하나, pipe 함수를 통해 pipe를 생성하고 dup2를 통해 pipe의 read end를 stdin으로 혹은 pipe의 write end를 stdout으로 지정하는 과정, pipe를 여닫는 과정 등이 추가된다. 일반적인 대부분의 프로세스들은 입력과 출력을 stdin에서 받거나 stdout으로 출력하기 때문에, pipe를 이용하여 입력과 출력을 다른 프로세스에 전달하는 데에 dup2 함수가 사용된다.\n자식 프로세스에서는 먼저, pipe를 생성한 뒤, |을 통해 구분된 명령어 단위로 프로세스를 실행한다.\n그리고, child process에서, dup2 를 이용하여 stdin으로 들어왔을 입력 대신 pipe의 read_end인 pipe_fd[0]에서 입력을 받아오고, stdout에 출력될 출력을 pipe의 write_end인 pipe_fd[1]에 입력되도록 한다. 단, 첫번째로 실행하는 프로세스일 경우에는 stdin에서 받아올 입력이 없기 때문에 stdin 대신 pipe_fd[0]에서 입력을 받아오는 동작은 생략한다.\n입력을 받아온 뒤에는 출력을 pipe의 write_end에 작성하기 위해서 read_end를 닫아준다.\n부모 프로세스에서는 자식 프로세스가 실행된 뒤, pipe의 write_end인 pipe_fd[1]을 닫아주어 pipe에 EOF임을 전달하도록 하였다.\n즉, 전체적으로 보았을 때, 파이프라인을 통하여 n개의 command가 입력되었을 때, 각 command를 실행하기 위해 n번의 fork가 일어난다.\n예시로, ls -al | wc -l | cat 와 같은 명령어를 입력하였을 때, command 별로 이를 [[&quot;ls&quot;, &quot;-al&quot;], [&quot;wc&quot;, &quot;-l&quot;], [&quot;cat&quot;]] 와 같이 parsing 해내고, 순차적으로 ls -al 명령을 실행하기 위해 fork 후 execvp 한 결과를 pipe_fd[1]에 넣고, pipe_fd[0]에서 wc -l이 이를 읽어와 fork 후 execvp 하여 실행한 결과한 pipe_fd[1]에 넣고, pipe_fd[0]에서 cat이 이를 읽어와 fork 후 execvp 한 결과를 최종적으로 stdout으로 출력한다. 즉 이와 같은 경우에서는 3번의 fork를 통해 프로세스가 실행되었다.\n이와 같은 과정을 거쳐 이전 프로세스의 출력이 파이프에 작성되고, 이를 다음 프로세스가 파이프에서 읽어와 pipelining이 구현될 수 있도록 하였다.\nLessons Learned §\n프로세스를 생성하는 과정에 대해서 알게 되었다. 단순히 exec를 통해 프로세스를 바로 실행하게 될 경우에는, 새로운 프로세스로 실행되는 것이 아닌, 현재 사용중인 프로세스에서 새로운 프로세스가 실행되는 것이기 때문에, 이전의 상태를 저장한 상태로 사용할 수 없다. 이를 위해 fork라는 과정을 거쳐 현재 프로세스를 그대로 복제한 자식 프로세스를 생성한 뒤, 자식 프로세스에서 exec를 통해 실행하게 된다. 자식 프로세스가 exit하면, wait을 통해 부모프로세스는 자식프로세스가 끝났음을 확인하고 그대로 동작을 진행할 수 있다.\n파이프라인으로 연결된 inter process communication 기법에 대해서도 직접 파이프 사용해보며 알 수 있었다. pipe file descriptor의 0번째 index는 pipe의 read end로 pipe에서 읽어오는 역할을, 1번째 index는 pipe의 write end로 pipe에 입력하는 역할을 한다. 파이프를 사용할 때, dup2를 이용하여 stdin의 입력을 pipe의 read end에서 입력받고, stdout의 출력을 pipe의 write end에 작성함으로써 pipe를 통하여 프로세스간 통신을 진행할 수 있었다. 디버깅 중에 가끔 프로그램이 가만히 멈춰있는 경우가 존재하였는데, 이는 파이프를 정상적으로 닫아주지 않아 EOF를 대기하던 상황이였음을 알 수 있었다."},"Projects/OS-Assignments/pa2":{"title":"PA2: Simulating Process Schedulers","links":[],"tags":["os","assignment","C"],"content":"https://github.com/parkjbdev/SCE213_OS/tree/os-pa2\nAbstract §\n이번 과제는 OS의 process scheduler를 구현하는 과제로, SJF scheduling, STCF scheduling, RR scheduling, Priority scheduling (including Basic Scheduling / Aging / Ceiling Protocol / Inheritance Protocol) 을 직접 구현하는 것이 목표이다.\nREADME.md에 주어진 각 스케줄러에 대한 testcases를 포함하여 주어진 모든 testcase에 대해서 올바른 결과가 나올 수 있도록 고안하였다.\n추가적으로, test*.sh file들은 컴파일과 실행이 정상적으로 종료되는지 확인하기 위해 작성한 스크립트이다.\nFIFO Scheduler §\nFIFO Scheduler는 first-in-first-out scheduler의 약자로, 프로세스가 ready된 순서대로 scheduling 해주는 policy 이다.\nFIFO Scheduler는 non-preemptive하게 동작하며, ready된 순서대로 스케줄링하기 때문에 starvation이 일어나지 않는다는 특징이 있다.\n하지만, 순차적으로 실행되는 특징 때문에, 비교적 lifespan 이 긴 프로세스가 lifespan 이 짧은 프로세스보다 먼저 스케줄링되는 경우, 전반적인 turnaround time 이 길어진다는 단점이 존재한다.\n이러한 단점을 보완하기 위해 lifespan 이 짧은 프로세스를 우선적으로 실행하는 SJF scheduling 방법을 이용할 수 있다.\nnon-preemptive 한 스케줄러이므로, current process 가 없어 아무것도 실행되고 있지 않은 경우에만 readyqueue 에 들어간 순서대로 scheduling 된다.\nSJF Scheduler §\nSJF Scheduler는 shortest-job-first scheduler의 약자로, 프로세스가 가장 먼저 끝나는 것을 우선적으로 실행하는 scheduling policy 이다.\nSJF Scheduler 역시 non-preemptive 하게 동작하는 scheduler 로, 한번 스케줄링되어 실행중인 process에 대해서는 중간에 다른 process 로 switch 하지 않는다. 하지만 FIFO scheduler 와는 달리 process 가 fork 된 순서가 아닌, shortest job process 를 우선적으로 스케줄링한다.\n이러한 특징으로 인해, lifespan이 짧은 프로세스가 계속해서 fork되었을 경우, lifespan이 긴 프로세스는 계속 대기하게 되는 starvation 현상이 나타날 수 있다.\nnon-preemptive 한 스케줄러이므로, current process 가 없어 아무 process 도 실행하지 않을 경우에 대해서만 shortest job을 찾는 과정을 통하여 scheduling 하여 구현은 간단하였다.\nSTCF Scheduler §\nSTCF Scheduler는 shortest-time-to-completion scheduler 의 약자로, non-preemptive 한 SJF Scheduler 를 개선한 preemptive 한 SJF scheduler 이다.\nSTCF Scheduler 역시 SJF Scheduler 와 마찬가지로, readyqueue 에 등록된 process 들 중에서 가장 먼저 끝나는 것을 가장 우선적으로 실행하는 scheduler 이다.\n따라서 SJF Scheduler 와 마찬가지로, 비교적 lifespan 이 짧은 process 가 계속하여 fork 된다면 작업을 끝내기까지 오랜시간이 걸리는 process 들은 계속 순위가 밀려 starvation 이 발생할 수 있다.\nPreemptive 한 scheduler 이기 때문에 앞선 두 scheduler 들과 달리, current process 가 실행중일 때에도 가장 먼저 끝날 수 있는 process 가 업데이트되어 달라지면, 해당 process 가 더 우선적으로 scheduling 될 수 있도록 하였다.\n초기 구현에서는 논리의 흐름이 보기 어려웠으나, 완성하고 다시 리팩토링을 진행한 결과, 결국 scheduler의 패턴들이 모두 비슷한 구조를 가지고 있음을 확인하였고, stcf 도 논리흐름이 더 잘보이도록 readable 하게 리팩토링하였다. (1dd4d6d)\n한가지 의문에 남았던 것은, 기존에 주어진 STCF Scheduler 의 주석에 forked 가 필요할 것이라고 주석을 통해 확인하였지만, 본인은 forked 함수의 구현 없이 scheduler 를 완성하였다는 점이다.\n현재 구현에서는 매 스케줄링마다 조건에 맞는 process 를 readyqueue 에서 순회하며 찾아서 scheduling 하였지만, forked 함수가 이용되는 로직이라면, 정렬된 readyqueue 를 이용하는 방식일 것으로 생각한다.\n프로세스가 생성될때마다 정렬된 readyqueue 에서 올바른 위치에 fork 된 프로세스를 옮겨주면, schedule 함수에서 readyqueue 를 순회하며 조건에 맞는 process 를 찾는 과정 없이 first_entry 를 뽑아 current process 와의 우선순위를 비교하여 scheduling 할 수 있기 때문이다.\n다만, 이렇게 readyqueue 를 관리한다면, SJF Scheduler 에 대해서도 마찬가지로 forked 함수가 필요할 것이다.\nRR Scheduler §\nRR Scheduler는 round-robin scheduler 의 약자로, 각 프로세스에게 동일한 time quantum 을 할당하여 scheduling 하는 scheduler 이다. 이번 프로젝트에서는 1tick을 하나의 time quantum으로 이용하였다. 기본적으로는 들어온 순서대로 1tick 씩 처리하며, process가 끝나지 않았다면 다음 차례에도 1tick씩 실행하기 위해서 readyqueue에 다시 배치된다.\n이러한 scheduling 방식으로 인해 round-robin scheduler는 preemptive 하며, starvation이 일어나지 않는다는 특징이 존재한다. 또, process의 response time 측면에서 이득을 볼 수 있다는 장점이 존재한다.\n이러한 특징을 가진 RR Scheduler의 구현은 STCF보다도 쉽게 구현할 수 있었다.\npreemptive한 fifo scheduler라고 생각할 수 있기 때문에, 큰 틀은 이와 유사하게 구현할 수 있었으며, 대신 1 tick 씩만 실행되고 readyqueue의 tail에 다시 저장할 수 있도록 구현하였다.\n초기에 RR Scheduler 를 구현할 때에는 이러한 FIFO Schedule 와의 공통적인 특징을 미처 생각하지 못하고, 논리흐름은 유사하지만 다른 코드로 구현하였다. 하지만, 이러한 공통적인 특징을 파악하고, 논리흐름을 더 직관적으로 이해할 수 있는 FIFO Scheduler 의 코드를 일부 재사용하여 재구현하였고, 출력결과는 모든 테스트케이스에 대해서 같음을 확인하였다. (955d15b1)\nPriority Scheduler §\nPriority Scheduler는 각 process의 priority 에 따라 scheduling 하는 순서가 결정되는 방식의 scheduler 이다.\n이번 프로젝트에서는 prio 멤버 변수의 크기가 클수록 더 높은 priority 를 가진 process 로 규정하였으며, readyqueue 에 대기하는 process 들 중에서 가장 높은 priority 를 가진 process 를 매 스케줄링마다 뽑아서 반환해주도록 하였다.\n즉, preemptive 한 형태의 priority scheduler 이다.\n또, 같은 priority 를 가진 process 들에 대해서는 rr scheduling 을 해주는 것이 목표이다.\n이번 priority scheduler의 구현에서 혼동되는 개념들과 잘못된 구현으로 인한 메모리 에러 및 assertion failure 때문에 초반에 난항을 많이 겪었다.\n특히 resource 를 acquire 하고 release 하는 과정에서 혼동이 많았는데, 처음 구현할 당시에 가장 크게 헷갈렸던 부분은 resource 를 acquire 하고 release 하는 과정에서 어느시점에 release 를 진행해야 하는지였다.\n우선 처음 잘못 이해한 priority scheduler 에서는, 만약 리소스가 이미 다른 더 우선순위가 낮은 프로세스에 의해 사용중인 상태일 때에는, 강제로 해당 리소스를 release 시키고서라도 priority 가 더 높은 프로세스에게 우선적으로 scheduling을 진행해 줄 수 있도록 해야한다고 생각하였다.\n하지만 이는 priority inversion에 대한 내용을 정확하게 숙지하지 못한 결과이다.\n만약, 우선순위가 더 높은 프로세스가 언제든 강제로 우선순위가 더 낮은 프로세스의 resource 를 뺏어와 우선순위가 더 높은 프로세스로 preempt 할 수 있었다면, priority inversion 과 같은 문제는 일어나지 않았을 것이다.\n하지만, 리소스의 특성상, 이미 사용중인 리소스에는 다른 프로세스가 접근하여 동시에 사용할 수 없기 때문에 강제로 리소스 사용을 해제하게 된다면, 이전에 리소스를 사용하여 진행하였던 tick들을 다시 진행해야 하는 상황이 발생한다.\n또, 더 높은 우선순위를 가진 process A가 resource 를 acquire 하였을 때, 낮은 우선순위를 가진 process B 에 의해 block 당했다면, block 시킨 process B 를 실행시켜야 더 높은 우선순위를 가진 프로세스A 가 우선적으로 실행될 수 있다고 생각하여, process B 로 스케줄링을 진행하려 하였다.\n하지만, 이런 스케줄러가 존재한다면, priority inversion 이 존재하지 않는 스케줄러가 되었을 것이다. 이 역시 priority inversion 에 대해서 잘못 이해하여 생긴 결과였다.\n두번째로 또 잘못 구현하였던 것은 readyqueue에서 PROCESS_READY state 에 있는 프로세스와 r-&gt;waitqueue 에서 PROCESS_BLOCKED state 에 있는 프로세스들을 혼용한 점이다.\nresource 를 요청하였지만 블락당한 프로세스들은 r-&gt;waitqueue 에 등록을 해주어 해당 리소스가 release 될 때에 다시 readyqueue 에 추가되어 scheduler 에서 자연스럽게 scheduling 될 수 있도록 해주어야 하는데, priority inversion에 대한 미숙한 이해와 이미 구현된 framework 의 이해 부족으로 scheduler 에서 직접 리소스들에 접근하려는 방법역시 시도하였지만, 사용이 제한된 함수여서 그렇게 하지 못하였다.\n그렇게 resource의 release 와 acquire 등에 대한 고민들에 대해서 다시 공부하고 QnA 등을 통해 해결하여 성공적으로 testcase를 통과할 수 있었다.\n막상 구현을 완성하고 모든 testcase를 통과하였더니 생각했던 것보다는 단순한 코드를 확인할 수 있었다. 이때의 논리흐름을 가독성있게 다시 정리하여 표현하여 보았더니 (1e77af93), rr_schedule 과 한라인을 제외하고 사실상 동일한 코드가 나옴을 확인할 수 있었다.\nrr_schedule 에서는 priority 에 대한 고려없이 스케줄링을 해주어 단순히 readyqueue 의 첫번째 엔트리를 스케줄링 하였지만, prio_schedule 에서는 priority 가 가장 높은 프로세스를 직접 구현한 find_process 함수를 통해 찾아 스케줄링 해주는 부분이 유일하게 다른 점이였다.\n위의 이해한 내용들을 바탕으로 resource를 acquire 하는 함수 prio_acquire 를 구현해 본 결과, 사실상 fcfs_acquire 와 같은 코드를 쓰고 있는 것을 발견하게 되었다.\nacquire 의 경우 resource 의 waitqueue에 등록될때 우선순위가 바뀌는 과정이 존재하지 않는다면, (ex. PIP/PCP Schedulin, aging의 경우 스케줄링 되면 prio가 초기상태로 돌아가므로 제외..) 그 과정은\n\n\n\n리소스 점유중이지 않으면 할당\n\n\n리소스가 점유되고 있는 중이면 해당 리소스의 waitqueue에 등록\n\n\n\n과 같은 과정으로 동일하게 나타난다.\nresource를 release 하는 함수 prio_release 역시 fcfs_release 와 거의 유사한 형태로, fcfs_release 는 단순히 waitqueue 에서 가장 첫번째 엔트리를 readyqueue 에 등록해준 반면, prio_release 는 waitqueue 에서 가장 우선순위가 높은 process를 readyqueue 에 등록해준다는 점에서만 차이가 존재하였다.\n이러한 시행착오들을 거쳐 구현을 완성하여 모든 testcase들을 통과할 수 있었다.\nPriority + Aging §\nPriority Scheduling with Aging은 말 그대로, 1 tick 이 흐를 때마다 readyqueue 에서 대기중인 프로세스들의 prio 를 1씩 높여주고, 스케줄링된 process의 경우 원래의 prio로 다시 초기화하는 방식을 채택한 priority scheduler 이다.\n이러한 방법을 이용하면, 기존의 priority scheduler에 비해서 starvation 을 예방할 수 있다는 장점이 존재한다.\n기본적인 틀은 기존의 priority scheduler와 동일하며, pa_schedule 에서도 prio_schedule 을 이용하여 다음에 실행될 프로세스를 scheduling 한다.\n다만, 스케줄링 받지 못한 프로세스들은 모두 prio 를 aging 시킨다는 점이 유일한 차이이다.\n기존의 priority scheduler를 이용한 scheduler 인지라, 구현은 간단하였다.\n구현 초반에 prio가 모두 1씩 높아지면, 당연히 서로의 우선순위간의 차이가 발생하지 않을 것이라 생각하고, 새로운 process가 fork 되는것이 아닌이상, aging이 무슨 의미가 있는것인지 생각하였는데, current를 제외하여 aging되며, scheduling 받는순간 원래의 priority로 돌아간다는 사실을 간과하고 있어서 발생한 문제였다.\n이를 인지하고, testcase들을 직접 계산해보았더니 이러한 priority aging scheduling을 이용하면, 아무리 priority가 제일 낮은 프로세스더라도, 계속하여 그 priority가 높아져 1tick 이라도 실행하여 starvation을 방지하는 것을 확인할 수 있었다.\nPriority + Ceiling Protocol §\nPriority Scheduling with Ceiling Protocol은 priority inversion을 방지하기 위한 해결책 중 하나로, priority가 더 높은 process가 요청한 resource가 block 당할 경우 priority inversion이 일어나지 않도록 기존에 resource를 점유하고 있는 process의 priority를 일시적으로 최대 priority로 boosting 하는 기법이다.\n또, 기존에 점유하고 있던 resource가 없어 acquire 하였다면, 자신의 priority 역시 최대로 boosting 하여 가장 우선적으로 끝날 수 있도록 한다.\n일시적인 priority boosting 이므로, 점유하고 있던 리소스를 release 할 때에는 원래의 priority로 돌아가게 된다.\npriority scheduling에 기반한 스케줄러에 resource 를 acquire 할 때, prio를 ceiling 으로 boosting 해주는 부분, resource 를 release 할 때, prio를 원래의 prio_orig 로 다시 돌려주는 과정만 추가해주면 되어서 구현에 어려움은 없었다.\nPriority + Inheritance Protocol §\nPriority Scheduling with Inheritance Protocol 역시 Ceiling Protocol와 함께 priority inversion을 방지하기 위한 해결책으로, block 시킨 더 낮은 우선순위를 가진 프로세스를 ceiling protocol과는 달리 최대 priority로 boosting 하지 않고, resource를 요청한 더 높은 프로세스의 priority를 상속받아 boosting하는 기법이다.\npip scheduling에서도 pcp scheduling과 마찬가지로, resource를 release 할 때에는 원래의 priority로 돌아와서 원래의 우선순위에 맞게 scheduling 될 수 있도록 한다.\npriority scheduling에 기반한 스케줄러에 resource 를 acquire 할 때, prio를 resource를 요청한 process의 priority로 설정해주는 부분과, resource 를 release 할 때는 ceiling protocol과 같은 과정으로 같은 함수를 이용하면 되어서 구현에 어려움은 없었다.\ntestcases/resources-adv2 을 실행하였을 경우 각 프로세스의 priority와 실행순서는 아래의 표와 같이 나타난다.\n아래으 표에서 priority를 표기할 때에, resource의 waitqueue에 존재하는 프로세스들은 [‘해당 리소스 번호’] ‘priority’ 와 같이 표기하였으며, priority 만 표기된 프로세스들은 모두 readyqueue에 존재하는 프로세스들이다.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntickProcess #1prioProcess #2prioProcess #3prioProcess #4prio0Nresource #1 acquired (1/2)resource #2 acquired (1/3)resource #3 acquired (1/4)resource #4 acquired (1/4)Run (1/4)010Nresource #1 blockedinherit prio to process #1525waiting resource #1[1] 5N10Nresource #1 blockedinherit prio to process #1303resource #1 (2/2)resource #2 (2/3)resource #3 (2/4)resource #4 (2/4)Run (2/4) resource #1 released→ adding process #4 to readyqueue30[1] 510Waiting resource #1[1] 3040[1] 510resource #1 acquired (1/1)Run (1/1)resource #1 released→adding process #2 to readyqueue30505Run 1/410Done605Run 2/410705resource #2 blockedinherit prio to process #1108resource #2 (3/3)resource #3 (3/4)resource #4 (3/4)Run (3/4)resource #2 released→ waitqueue is empty105waiting resource #2[2] 10905resource #2 acquired (1/2)Run 3/4101005resource #2 (2/2)Run 4/4resource #2 released10110resource #1 acquired (1/2)Run (1/3)5Done120resource #1 (2/2)resource #2 acquired (1/1)Run (2/3)resource #1 released→ waitqueue is emptyresource #2 released→ waitqueue is empty5…계속…\nLessons Learned §\n\nResource Acquistion 과 priority inversion 에 대한 이해가 부족하였지만, 이번 프로젝트를 통해 언제 resource 를 acquire 하고, release 할 때의 동작, block 당했을 때의 후속 동작 등을 직접 구현하면서 priority inversion 을 완벽하게 이해할 수 있었다.\npriority aging을 구현하면서 각 프로세스들의 priority 가 점점 높아져 1tick이라도 scheduling 되는 모습을 확인하였다. 이를 통해 starvation을 방지하는 과정을 확인하였다.\n올바르게 다시 이해한 priority inversion 내용에 바탕하여, 이러한 문제를 방지하기 위한 priority boosting 을 위한 ceiling protocol, inheritance protocol을 구현해보았다. testcases/resources-adv2 를 이용하여 기본 priority scheduling과 priority inheritance protocol 이 적용된 priority scheduling 의 실행결과를 비교해 보았다. (diffcheck 결과)\n그 결과, priority scheduling 의 3tick 에서 priority inversion이 발생하는 것을 확인할 수 있었고, inheritance protocol 을 적용하였을 때에는 priority 가 더 높은 process 4의 실행을 위해 process 1에게 priority를 상속해주었더니, priority inversion이 발생하지 않는 것을 확인할 수 있었다.\n프로그램을 작성할 때에, goto 문의 사용을 지양하고 기피하였는데, 이번 프로젝트에서는 이를 사용하지 않았을 때 오히려 가독성이 떨어지고 logic 의 흐름을 알아차기가 어려운 면이 존재하였다.\n모든 스케줄러들을 완성한 이후에 기존의 주어진 goto문이 사용된 fcfs_schedule 코드의 스타일을 적용할 수 있을지 각각의 스케줄러들을 다 확인하면서 최대한 유사한 구조로 리팩토링을 한 결과, 비슷한 구조로 적용이 가능했고, 더 readable 한 코드를 얻을 수 있었다.\n따라서 goto 문의 무조건적인 기피보다 필요에 따라 적절히 활용하여 더 효율적으로 작성이 가능하다면 이를 채택하고 사용하여도 되겠다는 생각이 들었다.\n"},"Projects/OS-Assignments/pa3":{"title":"PA3: Virtual Memory Simulator","links":[],"tags":["os","assignment","C"],"content":"https://github.com/parkjbdev/SCE213_OS/tree/os-pa3\nAbstract §\n이번 과제는 virtual memory simulator로, 프로세스가 읽을 수 있는 logical address (혹은 virtual address) 를 physical address로 변환해주는 MMU의 역할 중 일부를 수행하는 프로그램을 작성하는 것이다.\nLogical address는 Virtual Page Number (혹은 VPN)와 Offset으로 나뉘고, MMU가 Page Table을 참조하여 VPN을 Page Frame Number (혹은 PFN)로 바꾸면 실제 Page가 저장되어 있는 Physical Address를 알아낼 수 있다.\n이번 과제에서는 2 level hierachical page table을 사용하며, page table을 가리키는 outer page table가 정의되어있다.\n즉, VPN을 두 부분으로 나누어 각각 outer page table의 index 와 page table의 index를 알아내어 VPN에 해당하는 PTE (Page Table Entry)를 찾아 PFN을 알아낼 수 있도록 한다.\nPage Allocation §\n주어진 vpn에 대해서 새로운 page를 할당하는 과정이다.\n초기 구현과정에서 과제의 specification에 대해 혼동이 있어, vpn을 pfn으로 바꿔주는 것이 아닌, offset이 포함된 전체 virtual address를 pfn과 offset이 합해진 physical address로 바꾸어 주는 절차로 생각하였으나, virtual page number의 정의에 대해서 다시 생각해본 결과, virtual address의 offset은 고려하지 않아도 되는 사항임을 확인하였다.\ncommit 2b08f40: Implement alloc_page and free_page §\nallocation 을 진행할 때, 주어진 vpn에 대해 해당하는 pd_index와 pte_index를 찾아 해당하는 page table entry에 접근해야 한다.\n이를 위해서, 처음에는 비트 이동 연산자 &gt;&gt; 와 &lt;&lt;을 이용하여 다음과 같이 연산하는 방법을 고려하였다.\npd_index = vpn &gt;&gt; PTES_PER_PAGE_SHIFT;\npte_index = vpn &lt;&lt; (32 - PTES_PER_PAGE_SHIFT) &gt;&gt; (32 - PTES_PER_PAGE_SHIFT); // unsigned int uses 32bits\n여기에서 고려하지 않아도 되는 offset까지 고려하려고 하는 바람에 (사실 offset bit이 몇 bit을 차지하는지 알 수도 없다.) 비트연산자로 계산이 복잡해지고, 올바른 방법인지 의심하던중, vm.c의 __translate 함수에서 vpn을 NR_PTES_PER_PAGE로 나눈값과 나눈 나머지의 값으로 index를 알아내는 것을 확인후에, 올바르게 접근하는 방법을 알 수 있었다.\n위의 방법을 사용하여 pd_index와 pte_index를 알아낸 이후, pte_directory가 NULL로 선언되지 않은 상황일 때, 동적으로 할당해준 뒤에 올바른 page table entry들의 값을 할당해주며 초기화해주었다.\ncommit 88c1a07: implement: handle_page_fault §\nread only page에 write를 시도할 경우, page fault가 발생하여 page fault handler가 동작한다.\n이러한 상황에서, 이전에는 rw의 초기상태를 알 수 없어서, 해당 page가 read권한만 있는지, write권한도 있는지를 알 수 없었다.\n이를 page fault handler에서 알 수 있게 하기 위해, 이전의 pte의 private멤버에는 아무것도 할당하지 않았으나, rw의 초기상태를 allocation 과정에서 저장해 주기로 하였다.\nPage Deallocation §\n주어진 vpn에 대해 해당하는 pte를 해제시켜주는 과정이다.\nalloc_page에서와 같은 방식으로 pd_index와 pte_index를 계산하여 올바른 page table entry를 찾아간 뒤, valid bit을 false로 바꿔주는 과정이 주요한 요소이다. 이때, 해당하는 pfn을 referencing 하는 프로세스가 하나 줄어든 것이므로, mapcounts[pfn]의 값도 1만큼 감소시켜준다.\ncommit 2b08f403: Implement alloc_page and free_page §\n초기에 구현할 때, pte에 대한 혼동이 있어, 다른 프로세스도 공유한다고 생각하였는지, 현재 프로세스만 유일하게 해당 page frame을 참조하고 있을 때, valid bit을 false로 변경하는.. 코드를 작성하였는데, 이는 버그이다.\n당연하게도, 각 프로세스마다 pagetable이 따로 존재하며, free를 한다는 것은 더이상 해당 page table entry가 valid하지 않은 entry라는 것이기 때문에, 그러한 조건을 확인할 필요 없이, valid bit을 false로 바로 바꾸어주면 된다. 이는 commit d89cd9e6에서 수정되었다.\nFork §\n새로운 프로세스를 생성할 때, switch_process에서 fork하는 과정을 거쳐 생성한다.\n즉, 새로운 프로세스를 생성할 때, 기존 프로세스에서 사용된 모든 메모리 정보들이 새로운 프로세스에 똑같이 복사된다.\n이번 fork에서는 process dependent 한 정보인 pid와 list 멤버는 올바른 값으로 초기화시켜주고, pagetable을 그대로 복사해 주었다.\npagetable을 복사하기 전 Copy on write의 구현을 위해 전처리하는 과정을 거친다. 그 과정은 추후 자세히 설명한다.\n기존에 switch하려던 process가 존재하지 않을 경우 위와 같이 fork를 진행하며 pagetable을 복사해야 한다.\n이 과정을 처음에는 단순히 memcpy를 이용하여 복사하였으나, 이렇게 복사할 경우 pagetable을 shallow copy 한 것이 되어, 서로 다른 process 이더라도 같은 주소값을 참조하는 결과를 디버깅을 통해 확인하였다.\n따라서 이를 해결하기 위해 malloc을 통해 다시 동적으로 메모리를 할당하며, outer_pte와 ptes 모두 다른 주소공간에 같은 값을 복사할 수 있도록 pagetable을 deep copy해주는 함수 clone_pagetable을 통해 pagetable을 복제하여 새로운 프로세스에 할당해주었다.\n이 과정역시 copy on write을 이용하여 구현할 수는 있겠으나, 구현의 복잡성 때문에 우선 단순 deep copy하는 방식을 취하였다.\nCopy on Write §\n우선 다른 얘기이지만, Apple WWDC 2017에서 새롭게 소개된 APFS 파일 시스템을 소개할 때, copy on write이라는 것을 처음 접해보았다.\n당시에, 이러한 방법을 사용하면 파일을 논리적으로 복사할 때 속도도 빠르고, 물리적인 저장공간도 적게 사용할 수 있다는 점에서 센세이셔널하게 느꼈던 기억이 있다.\n약 6년이 지나고 운영체제 수업을 들으며 copy on write을 오랜만에 다시듣고, 간단하게 구현해보게 된다는 점에서 개인적으로 흥미를 느꼈다.\nAPFS의 Storage 차원의 CoW와 달리, 이번 과제에서의 CoW은 Memory 단에서 동작한다.\n말 그대로, copy on write은 copy를 lazy하게, write을 시도할 때 그제서야 copy를 하는 방법을 뜻한다. 그 구현은 다음의 일련의 과정과 같다.\n\nprocess fork를 시도하면, pte들의 rw bit을 read-only하게 바꾸어준다.\n그리고, 같은 page table을 deep copy하여 새로운 프로세스에 할당해 주면, 서로 다른 pagetable에서 같은 pfn을 참조한다.\n하지만, 부모 프로세스와 자식 프로세스 모두 pte의 rw bit이 read-only 하기 때문에, write을 시도할 경우 page fault가 발생한다.\n이와 같이 page fault가 발생할 경우, page fault handler에서 해당 page frame을 참조하는 프로세스의 개수(mapcounts)를 확인한다.\n\nmapcounts[pfn] == 1일 경우는 현재 프로세스만 해당 page frame을 참조하고 있는 상황으로 기존의 rw 권한을 복구시켜 준다.\nmapcounts[pfn] &gt; 1일 경우, 현재 프로세스 외에 다른 프로세스도 해당 page frame을 참조하고 있는 상황으로, page frame에 함부로 write 할 경우, 다른 process에 영향을 미치게 된다. 따라서, 새로운 page frame에 기존의 page frame을 복사하여 새로운 page frame을 참조하도록 pfn을 변경해준다.\n\n\n\n이를 구현하기 위해, switch_process의 fork 과정에서, pagetable을 복사하기 전에, valid한 pte에 대해서 mapcounts[pfn]을 1증가시키고, rw bit을 read-only하게 변경해준뒤, pagetable을 새로운 process에 deep copy 해주었다.\nhandle_page_fault에서는 read-only page에 write을 시도하여 page fault가 발생하였을 때, 위에서 언급한대로 핸들링하였다.\n즉, commit 39eb584d와 88c1a070이 사실상 copy on write을 구현한 commit이라고 보아도 무방하다.\nTestcase: testcases/cow-2 §\n우선, testcases/cow-2의 경우, NR_PTES_PER_PAGE=16을 넘어가는 vpn 주소의 할당은 없다.\n따라서, 모든 vpn의 outer_ptes는 0번째 ptes가 되므로 편의를 위해 outer_ptes에 대한 언급은 가급적 생략하도록 하겠다.\nallocation (@process#0) §\n먼저, process#0에서 vpn 0(r) 1(r) 2(rw) 3(rw)의 allocation이 진행된다.\n앞에서 언급했듯이, outer_ptes의 index는 0이고, 0번째 ptes는 다음과 같이 구성된다.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nindexvalidrwpfnprivate0Tr0r1Tr1r2Trw2rw3Trw3rw\nswitch (process#0 → process#1) §\nprocess#0 에서 process#1로 현재 실행중인 프로세스가 변경되었다.\n이때, process#1은 이전에 실횅된 적이 없는 프로세스로, process#0를 fork하여 새로운 프로세스를 만들게 된다.\n그 결과, process#1의 pagetable은 process#0의 pagetable과 같은 값을 가진다.\n다만, copy on write을 위해서, process#0의 pagetable을 process#1로 복사하기 전에 pte가 모두 ACCESS_READ 권한만 가지도록 하여, write을 할 수 없도록 한다.\n만약, 추후 write을 시도한다면, page fault가 발생하는데, 이때, page fault handler가 mapcounts를 확인하여 해당 page를 reference 하고 있는 process가 여러 개일 경우, 새로운 pfn을 할당 및 복사하여 해당 page frame에서 write이 가능하도록 변경한다.\n따라서, process#0과 process#1의 pte는 fork 된 후 다음과 같이 변경 혹은 할당된다.\npagetable of both process#0 and process#1 (identical) after switch 1 §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nindexvalidrwpfnprivate0Tr0r1Tr1r2Tr2rw3Tr3rw\nread &amp; write on process#1 §\nprocess#1의 read 1의 경우 read 권한이 있으므로 문제없이 동작한다.\nprocess#1의 write 2의 경우 fork를 하면서 write 권한이 사라졌기 때문에, 앞에서 언급했듯, page fault handler가 기존에 write가 가능한 page인지 확인 후, 가능하다면 새로운 pfn을 찾아서 할당 및 복사해준다.\n이번 경우, pfn 4번이 비어있는 가장 빠른 pfn이므로, 기존 2번의 page frame을 4번의 page frame에 복사하여 write 권한을 부여한다.\n따라서, process#1의 pte는 다음과 같이 변경된다.\npagetable of process#1 after read 1 and write 2 §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nindexvalidrwpfnprivate0Tr0r1Tr1r2Trw4rw3Tr3rw\nswitch (process#1 → process#2) §\nprocess#1 에서 process#2로 현재 실행중인 프로세스가 변경되었다.\n마찬가지로, process#2은 이전에 실횅된 적이 없는 프로세스로, process#0를 fork하여 새로운 프로세스를 만들면, read권한만 있는 pte들이 복사되어 다음과 같다.\npagetable of both process#1 and process#2 (identical) after switch 1 §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nindexvalidrwpfnprivate0Tr0r1Tr1r2Tr4rw3Tr3rw\nread &amp; write on process#2 §\nprocess#2에서 read 1을 시도하면, 위의 pagetable에서 1번째 index pte를 거쳐 문제없이 읽을 수 있다.\nprocess#2에서 write 3을 시도하면, 3번째 index pte는 read 권한만 가지고 있기 때문에 page fault가 발생하고, page fault handler가 기존 권한을 확인한 후 새로운 pfn를 찾아서 할당해준다.\n이번 경우, pfn 5번이 비어있는 가장 작은 pfn으로, 다음과 같이 pagetable이 변경된다.\npagetable of process#2 after read 1 and write 3 §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nindexvalidrwpfnprivate0Tr0r1Tr1r2Tr4rw3Trw5rw\nswitch (process#2 → process#0) §\nprocess#0은 기존에 생성되어 있던 프로세스로, processes에서 불러온다.\nprocess#0의 마지막 상태의 pagetable은 다음과 같았다.\npagetable of process#0 after switch 0 (loads last state of process#0’s pagetable) §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nindexvalidrwpfnprivate0Tr0r1Tr1r2Tr2rw3Tr3rw\n이때, read 2의 경우 정상적으로 pagetable을 확인하여 읽어올 수 있다.\nwrite 2를 할 경우, 2번 index는 read권한만 있기 때문에, page fault가 발생하여 page fault handler가 동작한다.\n하지만, mapcounts 배열에서 pfn 2를 참조하는 process가 자신으로 하나뿐이기 때문에, rw 권한으로 바꾸어도 다른 프로세스에 영향을 미치지 않는다.\n따라서 rw 권한으로 바꾼 뒤, pfn 2에 write을 한다.\npagetable of process#0 after write 2 §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nindexvalidrwpfnprivate0Tr0r1Tr1r2Trw2rw3Tr3rw\nwrite 3을 할 경우, 3번 index는 read 권한만 있기 때문에, page fault가 발생하여 page fault handler가 동작한다.\n2번 pfn과 달리 3번 pfn의 경우 현재 process#1 역시 참조하고 있는 상황이기 때문에 mapcounts에서 확인한 reference count는 2가 되며, 이에 따라 새로운 pfn을 할당해주어야 한다.\n따라서, 가장 작은 사용하지 않은 pfn인 6번을 할당후 rw권한을 부여해서 write를 할 수 있도록 변경된다.\n위와 같은 과정을 거친 process#0의 pagetable은 다음과 같다.\npagetable of process#0 after write 3 §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nindexvalidrwpfnprivate0Tr0r1Tr1r2Trw2rw3Trw6rw\n결국, 세 프로세스의 최종 pagetable의 상태는 다음과 같이 구성된다.\n\n  \n  process#0\n  process#1\n  process#2\n    \n      \n      \n      \n      index\n      valid\n      rw\n      pfn\n      private\n      \n      \n      \n      \n      0\n      T\n      r\n      0\n      r\n      \n      \n      1\n      T\n      r\n      1\n      r\n      \n      \n      2\n      T\n      rw\n      2\n      rw\n      \n      \n      3\n      T\n      rw\n      6\n      rw\n      \n      \n      ...\n      \n      \n      \n      \n      \n      \n      15\n      F\n      \n      \n      \n      \n      \n      \n    \n    \n      \n      \n      \n      index\n      valid\n      rw\n      pfn\n      private\n      \n      \n      \n      \n      0\n      T\n      r\n      0\n      r\n      \n      \n      1\n      T\n      r\n      1\n      r\n      \n      \n      2\n      T\n      rw\n      4\n      rw\n      \n      \n      3\n      T\n      r\n      3\n      rw\n      \n      \n      ...\n      \n      \n      \n      \n      \n      \n      15\n      F\n      \n      \n      \n      \n      \n      \n    \n    \n      \n      \n      \n      index\n      valid\n      rw\n      pfn\n      private\n      \n      \n      \n      \n      0\n      T\n      r\n      0\n      r\n      \n      \n      1\n      T\n      r\n      1\n      r\n      \n      \n      2\n      T\n      r\n      4\n      rw\n      \n      \n      3\n      T\n      rw\n      5\n      rw\n      \n      \n      ...\n      \n      \n      \n      \n      \n      \n      15\n      F\n      \n      \n      \n      \n      \n      \n    \n  \n\n\n다시한번 그 과정을 도식화하면 다음과 같다.\n\nTLB §\nTLB는 Translation Look-aside Buffer을 줄인말로, principle of locality 특성 때문에 이전에 읽거나 쓴 값은 앞으로도 읽거나 쓸 가능성이 높아 buffer에 해당 pte에 관한 정보를 적어두어 pagetable을 직접 참조하지 않고도, pte에 더욱 빠른 접근을 가능하게 하는 buffer이다.\n본래 의도는 pte에 더욱 빠르게 접근하기 위한 것이지만, 이번 과제에서는 tlb에서 일치하는 vpn을 찾는 과정에서 for loop을 거치기 때문에, 오히려 더 느릴 가능성이 존재하기는 하다.\n다만, 간단한 시뮬레이터임을 가정하므로 이러한 차이는 우선 무시하도록 한다.\nTLB를 구현할 때, process간 스위치가 되었을 경우에 대해 TLB를 어떻게 update 시켜야 할지에 대한 고민이 있었다.\nprocesss를 switch 할 때, 이전의 pid를 private 멤버에 저장하는 방법으로 즉, Address-Space Identifiers (ASIDs) 를 이용하는 방법도 존재하고, 그냥 tlb flush 시키는 방법도 있기 때문이다.\n하지만 결국 구현의 편의 때문에 tlb flush 시키는 방법을 선택하였다.\n또, 이번 과제에서는 입력이 적어 고려되지 않았지만, TLB entry가 NR_TLB_ENTRIES를 넘어 victim을 골라야 하는 상황이 발생할 수 있다.\n이러한 경우가 생긴다면, Belady’s Algorithm, FIFO, LRU 등등의 방법을 이용하여 victim page를 선택하여 해당 tlb entry 를 free시켜 사용하면 될 것이다.\nread 혹은 write operation을 하였을 때, 해당 vpn이 tlb에 적혀있는지 lookup_tlb를 통해서 참조하는 과정을 거친다.\n만약 해당 vpn에 대한 tlb entry가 존재하고, rw bit을 참조하여 허용되는 operation일 경우, tlb hit 된것으로 판단하여 tlb에 적혀진 pfn을 보고 MMU가 vpn을 변환하게 된다.\n하지만 tlb hit이 나지 않았을 경우, 추후에 참조할 가능성을 고려해서 tlb에 pte의 정보를 작성해주어야 한다.\n이를 위해서 먼저 주어진 vpn에 매칭하는 pte를 찾아 rw bit, pfn 값 등을 참조한다.\n이렇게 읽어온 값들을 insert_tlb에서 tlb에 삽입 혹은 update하게 되는 과정을 구현하면 tlb에 대한 주요 구현은 마무리 되었다.\n하지만, 사소하게 신경써주어야 하는것들로, pte의 값들이 바뀌었을 때, tlb의 값도 변경해서 update 해주어야 한다는 점이다.\n이번 과제의 경우, testcase에서 이를 검출하는 case는 존재하지 않아 문제없이 통과하였지만, 이를 고려하지 않는다면, page fault가 난 이후 write 하는 과정에서 tlb와 pte에 저장된 rw bit이나 pfn 값이 달라 문제가 발생할 수 있다.\n이러한 문제점을 인지하고, commit 253cc7f7에서 수정하였다.\n추후, vm.c를 확인하였는데, __translate 에서 insert_tlb를 통해서 tlb를 update 해주는 과정이 존재하는 것을 확인하고, 해당 코드를 삭제하였다.\ncommit f7f01b80: cleanup &amp; add comments §\n우선, pd라는 변수의 이름이 잘 와닿지 않아, 어려움이 있었는데, 결국 최종 pte를 알아내기 전의 마지막 page table 이므로, pt로 이름을 변경하였다.\n그리고, DRY(Don’t Repeat Yourself) 원칙과 readability를 위해서, pt와 pte를 구하는 과정을 get_pt와 get_pte라는 새로운 함수를 만들어 사용하였다.\nLessons Learned §\n\n이번 과제를 통해서 memory management unit이 pagetable을 조회하며 vpn을 pfn으로 변환하는 과정을 구현하며, vpn에 해당하는 pte를 어떻게 찾아가는 과정을 알 수 있었다.\n새로운 process를 fork할 때, shared memory를 사용하여 메모리를 효율적으로 사용하게 된다. 하지만, write을 할 때에는, 서로 다른 process 공유하고 있는 메모리에 작성할 경우 문제가 된다. 따라서, fork하는 process의 pte를 모두 read only page로 바꾸어준 뒤, write을 시도하여 page fault가 발생하면 handler가 그제서야 해당 page를 copy 해주는 방식인 Copy on write을 이용하였다. 또, 이런 과정을 거쳐, 해당 page를 참조하는 process가 결국 하나가 되었을 경우에는 다시 기존의 rw bit을 복구시켜주었다.\nTLB 를 이용하여 page table entry를 더욱 빨리 찾을 수 있는데, read 혹은 write 명령이 발생할 때마다, 이전에 TLB에 등록된 적이 없는 vpn이라면, TLB에 등록시키는 과정을 구현하였다. 또, 주어진 vpn과 rw 상태에 대해서 tlb hit이 나는지 판별하는 과정을 구현하였다. TLB를 이전에는 마냥 pagetable을 캐시해둔 것으로 추상적으로 알고 있었지만, 언제 등록되는지에 대해서는 자세히 알지 못하였다. 물론 실제 운영체제에서는 더 복잡한 조건이 있을 수 있지만, 이번 과제를 통해서 간단하게나마 알 수 있었다.\n\n"},"Projects/WePlan/01_Project-Proposal":{"title":"Project Proposal","links":[],"tags":["report"],"content":""},"Projects/WePlan/02_Requirements-Specification":{"title":"Requirements Specification","links":[],"tags":["report"],"content":""},"Projects/WePlan/03_Design-Document":{"title":"Design Document","links":[],"tags":["report"],"content":""},"Projects/WePlan/04_Final-Project-Report":{"title":"Final Project Report","links":[],"tags":["report"],"content":""},"Projects/WePlan/index":{"title":"WePlan - 공동공간 예약 서비스","links":[],"tags":["flutter","spring","keynote"],"content":"\n\nWePlan은 동아리의 공용공간 사용에 대한 일정관리 및 공유를 용이하게 해주는 서비스입니다.\n\n\n\nconst setRepoTheme = (theme) =&gt; {\n\tconst elems = document.querySelectorAll(&#039;.repo-card&#039;)\n\tfor (const elem of elems) {\n\t\tif (theme === &#039;dark&#039;)\n\t\t\telem.setAttribute(&#039;data-theme&#039;, &#039;dark-theme&#039;)\n\t\telse\n\t\t\telem.setAttribute(&#039;data-theme&#039;, &#039;light-default&#039;)\n\t}\n\twindow.tarptaeya.reloadRepoCards()\n}\nsetRepoTheme(document.documentElement.getAttribute(&#039;saved-theme&#039;))\ndocument.querySelector(&#039;#darkmode-toggle&#039;).addEventListener(&#039;change&#039;, (e) =&gt; setRepoTheme(e.target.checked ? &#039;dark&#039; : &#039;light&#039;))\n"},"Projects/cosmos/00_Mid-Report":{"title":"cosmos 중간보고서","links":["ARM/Exceptions/Exception-Vector-Table","ARM/Exceptions/Exception-Levels"],"tags":[],"content":"요약 §\n이번 프로젝트는 ARM 아키텍처에서 운영되는 간단한 커널을 Rust로 제작하는 것이다. 이를 통해 ARM 아키텍처에 대해서 학습하고, 운영체제 전반의 구조를 직접 제작해보며 운영체제에 대한 이해도를 향상시킬 것을 목적으로 한다. 더불어, 가급적 memory safe한 rust의 특징을 살려 잘못된 메모리 참조나 메모리 누수가 일어나지 않는 안전한 커널을 만들 수 있을 것으로 기대해본다.\n개요 §\n프로젝트와 QEMU 세팅, Bootloading, Interrupt Handling 의 순으로 커널을 제작하였다. 초기에 프로젝트를 제작할 때에, X86기반의 커널을 제작하는 튜토리얼을 참고하였지만, ARM 아키텍처에 적용하기에는 아키텍처 의존성 때문에 어려움이 있어 이미 제작되어 있는 다른 ARM 아키텍처의 커널들을 참고하며 개발을 진행하게 되었다. 그 중, 대표적으로 hermit-os의 kernel과 bootloader에서 kernel의 부팅절차를 확인하였으며, raspberry pi용 os 제작 튜토리얼에서 주로 ARM의 어셈블리 코드를 참조하였다. 가급적 Linux의 방식을 모사하고 싶었지만, 커널의 규모가 너무 방대하여 최소한의 기능만 갖춘 위의 커널들을 주로 참고하였다.\nBooting §\nX86의 부팅과정과 크게 다르지 않을 것이라고 생각하고 BIOS로 부팅하게 될 경우 16bit real mode에서 32bit protected mode로, 32bit protected mode에서 64bit long mode로 직접 transition 해주는 과정을 구현해야 될 것 같아 UEFI로 구현하려 하였다. 다음은 UEFI와 BIOS의 주요한 차이에 관한 내용이다.\n\nUEFI\n\nUnified Extensible Firmware Interface\nRequires EFI System Partition (ESP) to store .efi file\n.efi file includes all device initialization &amp; startup codes.. (could be kernel itself)\nUses GPT Partitioning scheme\n\n\nBIOS\n\nBasic Input Output System\nUses MBR Partitioning Scheme\nLegacy Way\nRequires 16bit-32bit-64bit transition since it starts on 16bit mode (x86)\n\n\n\n사실 ARM 아키텍쳐에서는 이러한 mode를 transition 하는 과정이 필요없다고 한다. UEFI 앱으로 빌드하여 개발을 하던 중, Interrupt 구현과정에서 어셈블리와 관련한 사소한 문제가 생겨 EFI 앱이 아닌 ELF앱으로 빌드하여 Bios로 부팅하기로 하였다. 결국, 기존의 구현하였던 UEFI 부분을 걷어낸 뒤, 일반적인 커널의 형태를 최대한 모사하기 위해서 Bootloader를 제작을 진행하려 하였고, 메모리에 로드된 Kernel ELF 의 주소를 직접 찾고, 매직넘버를 검사하여 올바른 ELF를 찾으면 이를 로드하는 방식으로 부팅하였다.\n하지만, 메모리에서 Kernel ELF를 찾은 뒤, 로딩하는 과정에서 어려움이 있어 Bootloader가 통합된 하나의 Kernel ELF로 제작하기로 하였다. 이에 따라, 기존의 uefi로 부팅하던 qemu 세팅을 bios (기본값)으로 부팅하도록 세팅을 바꾸고, hermit-loader가 커널을 찾아서 로딩하는 부분과 hermit-kernel이 loader에서 넘겨받아 커널이 켜지는 부분을 역으로 참조하며 부팅을 진행할 수 있도록 하였다.\nHermit의 경우, linker script를 이용하여 entry point와 각 메모리들의 section을 명시해주었고, 초기 검증과정 등을 거친 후에 rust 코드로 branch하는 방식으로 개발되어 있었다. 본인 역시 이와 유사하게 진행하였으나, 추후 Exception Level 1으로 Transition하여 Exception Vector Table을 등록해야 되어, 이와 관련된 처리도 추가적으로 해주었다.\n부팅이 완료된 후, stdout을 활성화시키기 위해서 0x40000000에 로드되어 있는 Device Tree를 참조하여 이를 담당하는 pl011 디바이스의 주소(0x09000000)를 찾아내고, 초기화 시켜주어 logging을 할 수 있었다.\nInterrupt §\nARM에서는 X86 아키텍처와는 다르게 Interrupt를 Exception의 일종으로 받아들인다. 따라서, X86의 Interrupt Descriptor Table이 존재하지 않고, Interrupt Request (IRQ) 혹은 Fast Interrupt Request (FIQ) 이 일어났을 때, Exception Vector Table를 참조하여 인터럽트에 대한 핸들러로 브랜치하고, 해당 핸들러에서 어떤 인터럽트인지 acknowledge를 한 이후, 이에 맞는 핸들러로 브랜치 시키는 방식을 이용한다. 이때 이용되는 Exception Vector Table은 다음과 같은 구조를 가지고 있다.\nException-Vector-Table\n이와 같이 armv7의 exception vector와 armv8의 exception vector가 다른 구조로 구성되어 있다. cortex-a76 CPU에서 동작할 것을 상정하고 제작하기에, armv8의 exception vector table구조를 따랐다.\n위의 Exception 이 들어왔을 때, 기존 프로그램의 실행 상태를 저장하고 handling을 처리하도록 하였으며, 여기에서 올바르지 않은 레지스터에 등록하였는지 오류가 발생하였지만 곧이내 해결할 수 있었다. Exception Vector Table의 각 field에서는 rust 코드로 branch하여 interrupt id를 확인하고 이에 맞는 핸들러를 불러와 수행하도록 하였다.\nException Vector Table을 등록하기 위해서는 ARM의 VBAR 레지스터에 등록해야 하는데, 올바른 Exception Level의 VBAR 레지스터에 등록해야 해당 레벨에서의 익셉션을 처리할 수 있다. Exception의 종류는 다음과 같다.\nException-Levels\n현재로써는 가상화를 생각하지 않고 커널의 권한만 필요하기에 EL1으로 부팅하였다. (부팅할 때에는 EL2로 부팅되지만, EL1으로 Transition하는 과정을 추가하였다.)\n추가적으로, ARM에서는 GIC를 이용하여 Software Interrupt를 발생시키거나, Interrupt ID를 acknowledge한다. GIC를 사용하기 위해서 Device Tree에서 GICD, GICC의 주소를 읽어와 디바이스를 초기화시켜주었다.\nMemory §\nQEMU에서는 ARM아키텍처를 에뮬레이션하기 위해서 virt라는 가상의 보드를 이용한다. Virt board의 메모리 레이아웃을 확인하기 위해서 qemu의 소스코드를 확인하여 본 결과 다음과 같은 레이아웃을 가지고 있었다.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNAMESTART_ADDREND_ADDRLENBoot Rom RESERVED (0 to 0x08000000)&lt;&lt;&lt;VIRT_FLASH0x000000000x080000000x08000000VIRT_CPUPERIPHS0x080000000x080200000x00020000GICD &amp; GICC sits inside CPU Peripheral space&lt;&lt;&lt;VIRT_GIC_DIST0x080000000x080100000x00010000VIRT_GIC_CPU0x080100000x080200000x00010000VIRT_GIC_V2M0x080200000x080210000x00001000VIRT_GIC_HYP0x080300000x080400000x00010000VIRT_GIC_VCPU0x080400000x080500000x00010000The space in between here is reserved for GICv3 CPU/vCPU/HYP&lt;&lt;&lt;VIRT_GIC_ITS0x080800000x080A00000x00020000This redistributor space allows up to 264kB123 CPUs&lt;&lt;&lt;VIRT_GIC_REDIST0x080A00000x090000000x00F60000VIRT_UART0x090000000x090010000x00001000VIRT_RTC0x090100000x090110000x00001000VIRT_FW_CFG0x090200000x090200180x00000018VIRT_GPIO0x090300000x090310000x00001000VIRT_SECURE_UART0x090400000x090410000x00001000VIRT_SMMU0x090500000x090700000x00020000VIRT_PCDIMM_ACPI0x090700000x090700180x00000018VIRT_ACPI_GED0x090800000x090800040x00000004VIRT_NVDIMM_ACPI0x090900000x090900040x00000004VIRT_PVTIME0x090A00000x090B00000x00010000VIRT_SECURE_GPIO0x090B00000x090B10000x00001000VIRT_MMIO0x0A0000000x0A0002000x00000200VIRT_PLATFORM_BUS0x0C0000000x0E0000000x02000000VIRT_SECURE_MEM0x0E0000000x010000000x01000000VIRT_PCIE_MMIO0x100000000x3EFF00000x2eff0000VIRT_PCIE_PIO0x3EFF00000x3F0000000x00010000VIRT_PCIE_ECAM0x3F0000000x400000000x01000000VIRT_MEM0x400000000x40400000000x4000000000Customizable Area&lt;&lt;&lt;QEMU_DTB0x400000000x402000000x00200000COSMOS_RAM_START0x40200000\n여기에서, 램의 시작 주소는 0x40000000 인데, 해당 위치에는 qemu가 dtb를 로드해 두었기 때문에, 여유있게 0x40200000부터 메모리 공간을 이용하도록 linker script를 구성하였다. 0x40200000부터의 섹션들은 다음과 같다.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n섹션역할권한.text커널의 실행할 코드가 위치할 메모리 영역r-x.rodata컴파일 시에 값이 정해지고 변경되지 않는 전역 상수 데이터r—.gotRelocation 관련.. 아직 사용하지 않음r—.data컴파일 시에 값이 정해지는 전역 변수 데이터rw-.bss컴파일 시에 초기값이 할당되지 않은 전역변수rw-Heap동적으로 할당할 수 있는 메모리의 영역..아직 구현되지 않음Stack프로세스의 스택이 위치하는 메모리 영역\n아직 heap 영역에 대해서는 구현되지 않았으며, 스택 역시 주소공간만 충분히 할당해 주었다. 이는 Virtual Memory와 관련된 구현을 할 때 함께 진행할 계획이다.\nReferences §\nPhilipp Oppermann’s blog\nhttps://os.phil-opp.com/freestanding-rust-binary/\nRunning a full arm64 system stack under QEMU\nhttps://cdn.kernel.org/pub/linux/kernel/people/will/docs/qemu/qemu-arm64-howto.html\nUEFI vs BIOS\nhttps://phoenixnap.com/kb/uefi-vs-bios \nDevicetree in QEMU\nhttps://docs.u-boot.org/en/latest/develop/devicetree/dt_qemu.html \nDeviceTree Specification\nhttps://devicetree-specification.readthedocs.io/en/stable/index.html \nFlattened Device Tree Format\nhttps://devicetree-specification.readthedocs.io/en/v0.3/flattened-format.html\nhttps://velog.io/@coral2cola/ARM-Interrupts-1 \nhttps://velog.io/@coral2cola/ARM-Interrupts-2 \nhttps://grasslab.github.io/osdi/en/labs/lab3.html \nLinux - ARM architected timer:\nhttps://kernel.org/doc/Documentation/devicetree/bindings/arm/arch_timer.txt \nLinux - ARM Generic Interrupt Controller, version 3\nhttps://www.kernel.org/doc/Documentation/devicetree/bindings/interrupt-controller/arm%2Cgic-v3.txt \nHermit Kernel: https://hermit-os.org/kernel\nHermit Loader: http://hermit-os.org/loader \nrust-raspberrypi os tutorial: https://github.com/rust-embedded/rust-raspberrypi-OS-tutorials \nALIGN in Linker Scripts\nhttps://stackoverflow.com/questions/8458084/align-in-linker-scripts\nLinux Memory Layout\nhttps://hackyboiz.github.io/2022/01/14/poosic/linux-memory-layout/\nQEMU\nhttps://github.com/qemu/qemu"},"Projects/cosmos/01_Intro":{"title":"Introduction","links":[],"tags":[],"content":"본 프로젝트는 aarch64를 타겟으로 하는 rust로 작성된 os를 제작하는 것이다.\n이번에는 간단하게 부팅되는 더미커널만을 제작하는 것을 목표로 하였다.\nBuilding Freestanding Rust Binary (or Dummy Kernel) §\nCreate Project §\ncargo new cosmos\nDisable Standard Library §\n// src/main.rs\n#![no_std]\nPanic Handling §\nImplement Panic Handler §\n// src/main.rs\n \n#[panic_handler]\nfn handle_panic(_info: &amp;PanicInfo) -&gt; ! {\n\tloop{}\n}\nDisable stack unwinding §\n# Cargo.toml\n \n[profile.dev]\npanic = &quot;abort&quot;\n \n[profile.release]\npanic = &quot;abort&quot;\nUnless.. §\n   Compiling cosmo-kernel v0.1.0 (/home/parkjb/cosmo-kernel)\nerror: language item required, but not found: `eh_personality`\n  |\n  = note: this can occur when a binary crate with `#![no_std]` is compiled for a target where `eh_personality` is defined in the standard library\n  = help: you may be able to compile for a target that doesn&#039;t need `eh_personality`, specify a target with `--target` or in `.cargo/config`\n \nerror: could not compile `cosmo-kernel` (bin &quot;cosmo-kernel&quot;) due to previous error\neh_personality is for implementing stack unwinding to run the destructors of all live stack variables in case of panic.\nThis ensures all memory used is freed and allows parent thread to catch the panic and continue execution.\nDrawbacks: increases the size of the executable.. abort on panic option can be useful instead.\nAdd Compile Target §\nrustup target add aarch64-unknown-none\nPlatform Support: https://doc.rust-lang.org/nightly/rustc/platform-support.html\nEntry Point §\nDisable main entry point §\n#![no_main]\n// -- fn main()\nEntry Point: _start §\n#[no_mangle]\npub extern &quot;C&quot; fn _start() -&gt; ! {\n    loop {}\n}\nno_mangle §\nno_mangle은 컴파일러에게 함수의 이름을 바꾸지 않도록 지시하는 어노테이션이다.\n_start 함수가 mangling 된다면, 엔트리 포인트를 찾지 못하여 커널을 정상적으로 시작할 수 없게된다.\nhttps://doc.rust-kr.org/ch19-01-unsafe-rust.html#다른-언어에서-러스트-함수-호출하기\nUnless.. §\n   Compiling cosmos v0.1.0 (/home/parkjb/cosmos)\nerror: requires `start` lang_item\n \nerror: could not compile `cosmos` (bin &quot;cosmos&quot;) due to 1 previous error\nUseful Tools §\nInstall §\ncargo install cargo-binutils\nrustup component add llvm-tools\nrust-nm: List Symbols §\nrust-nm target/aarch64-unknown-none/debug/kernel\n0000000000210120 T _start\n\nrust-objdump: Inspect ELF File §\n\nELF: Executable &amp; Linkable File\n\nFile Headers: -f §\nrust-objdump -f target/aarch64-unknown-none/debug/kernel\ntarget/aarch64-unknown-none/debug/kernel:\tfile format elf64-littleaarch64\narchitecture: aarch64\nstart address: 0x0000000000210120\n\nSections: -h §\nrust-objdump -h target/aarch64-unknown-none/debug/kernel\ntarget/aarch64-unknown-none/debug/kernel:\tfile format elf64-littleaarch64\n\nSections:\nIdx Name           Size     VMA              Type\n  0                00000000 0000000000000000\n  1 .text          00000008 0000000000210120 TEXT\n  2 .debug_abbrev  00000133 0000000000000000 DEBUG\n  3 .debug_info    000005f3 0000000000000000 DEBUG\n  4 .debug_aranges 00000040 0000000000000000 DEBUG\n  5 .debug_ranges  00000030 0000000000000000 DEBUG\n  6 .debug_str     00000499 0000000000000000 DEBUG\n  7 .comment       00000040 0000000000000000\n  8 .debug_frame   00000050 0000000000000000 DEBUG\n  9 .debug_line    00000058 0000000000000000 DEBUG\n 10 .symtab        00000120 0000000000000000\n 11 .shstrtab      00000085 0000000000000000\n 12 .strtab        00000047 0000000000000000\n\nDisassembling: -d §\nrust-objdump -d target/aarch64-unknown-none/debug/kernel\ntarget/aarch64-unknown-none/debug/kernel:\tfile format elf64-littleaarch64\n\nDisassembly of section .text:\n\n0000000000210120 &lt;_start&gt;:\n  210120: 14000001     \tb\t0x210124 &lt;_start+0x4&gt;\n  210124: 14000000     \tb\t0x210124 &lt;_start+0x4&gt;\n\nrust-strip §\nrust-strip target/aarch64-unknown-none/debug/kernel\n\nremoves debug information\n\nReference §\n\nPhilipp Oppermann’s blog: https://os.phil-opp.com/freestanding-rust-binary/\n"},"Projects/cosmos/02_QEMU":{"title":"QEMU 세팅","links":[],"tags":[],"content":"QEMU 세팅 §\n공통 §\nPreparing Disk §\nqemu-img create -f qcow2 disk.img 16G\nGDB §\nQEMU Option for attaching GDB:  -S -s\ngdb-multiarch\n \n(gdb) target remote :1234\nDevice Tree §\n\nQEMU Option for dumping DTB: -machine dumpdtb=${DTB_FILE}\nDTB to DTS Conversion: dtc -I dtb -O dts ${DTB_FILE} -o {DTS_FILE}\n\nUEFI §\nPreparing UEFI firmware.. §\nsudo apt-get install qemu-efi-aarch64\ntruncate -s 64m varstore.img\ntruncate -s 64m efi.img\ndd if=/usr/share/qemu-efi-aarch64/QEMU_EFI.fd of=efi.img conv=notrunc\nLaunch QEMU §\nqemu-system-aarch64 -M virt  \\\n      -machine virtualization=true -machine virt,gic-version=3  \\\n      -cpu max,pauth-impdef=on -smp 2 -m 4096           \\\n      -drive if=pflash,format=raw,file=efi.img,readonly=on      \\\n      -drive if=pflash,format=raw,file=varstore.img         \\\n      -drive if=virtio,format=qcow2,file=disk.img           \\\n      -device virtio-scsi-pci,id=scsi0              \\\n      -object rng-random,filename=/dev/urandom,id=rng0      \\\n      -device virtio-rng-pci,rng=rng0               \\\n      -device virtio-net-pci,netdev=net0                \\\n      -netdev user,id=net0,hostfwd=tcp::8022-:22            \\\n      -nographic                            \\\n      -drive if=none,id=cd,file=debian-12.2.0-arm64-netinst.iso \\\n      -device scsi-cd,drive=cd\nBIOS §\nLaunch QEMU §\nqemu-system-aarch64 \\\n\t-machine virt,gic-version=3,virtualization=true  \\\n    -cpu ${CPU} -smp ${CPU_CORE} -m ${RAM_SIZE}           \\\n    -semihosting \\\n    -kernel ${KERNEL} \\\n    -drive if=virtio,format=${DISK_FORMAT},file=${DISK_IMG}          \\\n\t-nographic -serial mon:stdio\nReference §\n\nRunning a full arm64 system stack under QEMU: https://cdn.kernel.org/pub/linux/kernel/people/will/docs/qemu/qemu-arm64-howto.html\n"},"Projects/cosmos/03_Booting":{"title":"Booting","links":[],"tags":[],"content":"The Boot Process §\n\nExecutes Motherboard ROM firmware code\n\npower-on-self-test(https://en.wikipedia.org/wiki/Power-on_self-test)\ndetect available RAM\npre-initialize CPU &amp; other hardwares\nlooks for bootable disk\n\n\n\nPatch for bootloader_api crate §\nbootloader_api를 이용하려 하였으나, x86 dependent한 요소가 많아 더 이상 이용하지 않음\n\n\nTranslate instruction from x86 to aarch64\nReference\n\nhttps://developer.arm.com/documentation/dui0068/b/ARM-Instruction-Reference/ARM-general-data-processing-instructions/ADD—SUB—RSB—ADC—SBC—and-RSC\nhttps://c9x.me/x86/html/file_module_x86_id_5.html\n\n\n\nBootable Disk Image §\n\nUpdate: abandon creating disk image since our os will boot on uefi-app\nUpdate: abandon uefi since there were some compatibility issue when using asm\n\nmkdir kernel\nmv src kernel/\nmv Cargo.toml kernel/\ncargo init --new cosmos\n# top-level Cargo.toml\n[workspace]\nmembers = [&quot;kernel&quot;]\nUEFI APP §\nrustup install nightly\n# rust-toolchain.toml\n[toolchain]\nchannel = &quot;nightly&quot;\nrustup target add aarch64-unknown-uefi\ncargo build --target aarch64-unknown-uefi\nBIOS vs UEFI §\nBIOS §\nBasic Input Output System\n\nStored in EPROM (Erasable Programmable Read Only Memory)\nUses MBR Partitioning Scheme\nLegacy Way\nRequires 16bit-32bit-64bit transition since it starts on 16bit mode\n\n\nUEFI §\nUnified Extensible Firmware Interface\n\nRequires EFI System Partition (ESP) to store .efi file\n.efi file includes all device initialization &amp; startup codes.. (could be kernel itself)\nUses GPT Partitioning scheme\n\n\nReference §\n\nphil-opp/blog-os: https://github.com/phil-opp/blog_os/blob/edition-3/blog/content/edition-3/posts/02-booting/index.md\nUEFI vs BIOS: https://phoenixnap.com/kb/uefi-vs-bios\n"},"Projects/cosmos/04_Device-Tree":{"title":"Device Tree","links":[],"tags":[],"content":"Device Tree §\nMay Change if some configurations changed.. (ex. more cpu smp etc.)\n/dts-v1/;\n \n/ {\n\tinterrupt-parent = &lt;0x8002&gt;;\n\tmodel = &quot;linux,dummy-virt&quot;;\n\t#size-cells = &lt;0x02&gt;;\n\t#address-cells = &lt;0x02&gt;;\n\tcompatible = &quot;linux,dummy-virt&quot;;\n \n\tpsci {\n\t\tmigrate = &lt;0xc4000005&gt;;\n\t\tcpu_on = &lt;0xc4000003&gt;;\n\t\tcpu_off = &lt;0x84000002&gt;;\n\t\tcpu_suspend = &lt;0xc4000001&gt;;\n\t\tmethod = &quot;smc&quot;;\n\t\tcompatible = &quot;arm,psci-1.0\\0arm,psci-0.2\\0arm,psci&quot;;\n\t};\n \n\tmemory@40000000 {\n\t\treg = &lt;0x00 0x40000000 0x01 0x00&gt;;\n\t\tdevice_type = &quot;memory&quot;;\n\t};\n \n\tplatform-bus@c000000 {\n\t\tinterrupt-parent = &lt;0x8002&gt;;\n\t\tranges = &lt;0x00 0x00 0xc000000 0x2000000&gt;;\n\t\t#address-cells = &lt;0x01&gt;;\n\t\t#size-cells = &lt;0x01&gt;;\n\t\tcompatible = &quot;qemu,platform\\0simple-bus&quot;;\n\t};\n \n\tfw-cfg@9020000 {\n\t\tdma-coherent;\n\t\treg = &lt;0x00 0x9020000 0x00 0x18&gt;;\n\t\tcompatible = &quot;qemu,fw-cfg-mmio&quot;;\n\t};\n \n\tvirtio_mmio@a000000 {\n\t\tdma-coherent;\n\t\tinterrupts = &lt;0x00 0x10 0x01&gt;;\n\t\treg = &lt;0x00 0xa000000 0x00 0x200&gt;;\n\t\tcompatible = &quot;virtio,mmio&quot;;\n\t};\n\t\n\t...(생략)\n \n\tvirtio_mmio@a003e00 {\n\t\tdma-coherent;\n\t\tinterrupts = &lt;0x00 0x2f 0x01&gt;;\n\t\treg = &lt;0x00 0xa003e00 0x00 0x200&gt;;\n\t\tcompatible = &quot;virtio,mmio&quot;;\n\t};\n \n\tgpio-keys {\n\t\tcompatible = &quot;gpio-keys&quot;;\n \n\t\tpoweroff {\n\t\t\tgpios = &lt;0x8004 0x03 0x00&gt;;\n\t\t\tlinux,code = &lt;0x74&gt;;\n\t\t\tlabel = &quot;GPIO Key Poweroff&quot;;\n\t\t};\n\t};\n \n\tpl061@9030000 {\n\t\tphandle = &lt;0x8004&gt;;\n\t\tclock-names = &quot;apb_pclk&quot;;\n\t\tclocks = &lt;0x8000&gt;;\n\t\tinterrupts = &lt;0x00 0x07 0x04&gt;;\n\t\tgpio-controller;\n\t\t#gpio-cells = &lt;0x02&gt;;\n\t\tcompatible = &quot;arm,pl061\\0arm,primecell&quot;;\n\t\treg = &lt;0x00 0x9030000 0x00 0x1000&gt;;\n\t};\n \n\tpcie@10000000 {\n\t\tinterrupt-map-mask = &lt;0x1800 0x00 0x00 0x07&gt;;\n\t\tinterrupt-map = &lt;0x00 0x00 0x00 0x01 0x8002 0x00 0x00 0x00 0x03 0x04 0x00 0x00 0x00 0x02 0x8002 0x00 0x00 0x00 0x04 0x04 0x00 0x00 0x00 0x03 0x8002 0x00 0x00 0x00 0x05 0x04 0x00 0x00 0x00 0x04 0x8002 0x00 0x00 0x00 0x06 0x04 0x800 0x00 0x00 0x01 0x8002 0x00 0x00 0x00 0x04 0x04 0x800 0x00 0x00 0x02 0x8002 0x00 0x00 0x00 0x05 0x04 0x800 0x00 0x00 0x03 0x8002 0x00 0x00 0x00 0x06 0x04 0x800 0x00 0x00 0x04 0x8002 0x00 0x00 0x00 0x03 0x04 0x1000 0x00 0x00 0x01 0x8002 0x00 0x00 0x00 0x05 0x04 0x1000 0x00 0x00 0x02 0x8002 0x00 0x00 0x00 0x06 0x04 0x1000 0x00 0x00 0x03 0x8002 0x00 0x00 0x00 0x03 0x04 0x1000 0x00 0x00 0x04 0x8002 0x00 0x00 0x00 0x04 0x04 0x1800 0x00 0x00 0x01 0x8002 0x00 0x00 0x00 0x06 0x04 0x1800 0x00 0x00 0x02 0x8002 0x00 0x00 0x00 0x03 0x04 0x1800 0x00 0x00 0x03 0x8002 0x00 0x00 0x00 0x04 0x04 0x1800 0x00 0x00 0x04 0x8002 0x00 0x00 0x00 0x05 0x04&gt;;\n\t\t#interrupt-cells = &lt;0x01&gt;;\n\t\tranges = &lt;0x1000000 0x00 0x00 0x00 0x3eff0000 0x00 0x10000 0x2000000 0x00 0x10000000 0x00 0x10000000 0x00 0x2eff0000 0x3000000 0x80 0x00 0x80 0x00 0x80 0x00&gt;;\n\t\treg = &lt;0x40 0x10000000 0x00 0x10000000&gt;;\n\t\tmsi-map = &lt;0x00 0x8003 0x00 0x10000&gt;;\n\t\tdma-coherent;\n\t\tbus-range = &lt;0x00 0xff&gt;;\n\t\tlinux,pci-domain = &lt;0x00&gt;;\n\t\t#size-cells = &lt;0x02&gt;;\n\t\t#address-cells = &lt;0x03&gt;;\n\t\tdevice_type = &quot;pci&quot;;\n\t\tcompatible = &quot;pci-host-ecam-generic&quot;;\n\t};\n \n\tpl031@9010000 {\n\t\tclock-names = &quot;apb_pclk&quot;;\n\t\tclocks = &lt;0x8000&gt;;\n\t\tinterrupts = &lt;0x00 0x02 0x04&gt;;\n\t\treg = &lt;0x00 0x9010000 0x00 0x1000&gt;;\n\t\tcompatible = &quot;arm,pl031\\0arm,primecell&quot;;\n\t};\n \n\tpl011@9000000 {\n\t\tclock-names = &quot;uartclk\\0apb_pclk&quot;;\n\t\tclocks = &lt;0x8000 0x8000&gt;;\n\t\tinterrupts = &lt;0x00 0x01 0x04&gt;;\n\t\treg = &lt;0x00 0x9000000 0x00 0x1000&gt;;\n\t\tcompatible = &quot;arm,pl011\\0arm,primecell&quot;;\n\t};\n \n\tpmu {\n\t\tinterrupts = &lt;0x01 0x07 0x04&gt;;\n\t\tcompatible = &quot;arm,armv8-pmuv3&quot;;\n\t};\n \n\tintc@8000000 {\n\t\tphandle = &lt;0x8002&gt;;\n\t\tinterrupts = &lt;0x01 0x09 0x04&gt;;\n\t\treg = &lt;0x00 0x8000000 0x00 0x10000 0x00 0x80a0000 0x00 0xf60000&gt;;\n\t\t#redistributor-regions = &lt;0x01&gt;;\n\t\tcompatible = &quot;arm,gic-v3&quot;;\n\t\tranges;\n\t\t#size-cells = &lt;0x02&gt;;\n\t\t#address-cells = &lt;0x02&gt;;\n\t\tinterrupt-controller;\n\t\t#interrupt-cells = &lt;0x03&gt;;\n \n\t\tits@8080000 {\n\t\t\tphandle = &lt;0x8003&gt;;\n\t\t\treg = &lt;0x00 0x8080000 0x00 0x20000&gt;;\n\t\t\t#msi-cells = &lt;0x01&gt;;\n\t\t\tmsi-controller;\n\t\t\tcompatible = &quot;arm,gic-v3-its&quot;;\n\t\t};\n\t};\n \n\tflash@0 {\n\t\tbank-width = &lt;0x04&gt;;\n\t\treg = &lt;0x00 0x00 0x00 0x4000000 0x00 0x4000000 0x00 0x4000000&gt;;\n\t\tcompatible = &quot;cfi-flash&quot;;\n\t};\n \n\tcpus {\n\t\t#size-cells = &lt;0x00&gt;;\n\t\t#address-cells = &lt;0x01&gt;;\n \n\t\tcpu-map {\n\t\t\tsocket0 {\n\t\t\t\tcluster0 {\n\t\t\t\t\tcore0 {\n\t\t\t\t\t\tcpu = &lt;0x8001&gt;;\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t};\n\t\t};\n \n\t\tcpu@0 {\n\t\t\tphandle = &lt;0x8001&gt;;\n\t\t\treg = &lt;0x00&gt;;\n\t\t\tcompatible = &quot;arm,cortex-a76&quot;;\n\t\t\tdevice_type = &quot;cpu&quot;;\n\t\t};\n\t};\n \n\ttimer {\n\t\tinterrupts = &lt;0x01 0x0d 0x04 0x01 0x0e 0x04 0x01 0x0b 0x04 0x01 0x0a 0x04&gt;;\n\t\talways-on;\n\t\tcompatible = &quot;arm,armv8-timer\\0arm,armv7-timer&quot;;\n\t};\n \n\tapb-pclk {\n\t\tphandle = &lt;0x8000&gt;;\n\t\tclock-output-names = &quot;clk24mhz&quot;;\n\t\tclock-frequency = &lt;0x16e3600&gt;;\n\t\t#clock-cells = &lt;0x00&gt;;\n\t\tcompatible = &quot;fixed-clock&quot;;\n\t};\n \n\tchosen {\n\t\tstdout-path = &quot;/pl011@9000000&quot;;\n\t\trng-seed = &lt;0x45efbb7b 0x6d473e1e 0xc4883b80 0x72c67d86 0x5215531b 0x9cb909a4 0x775c5488 0x864f215b&gt;;\n\t\tkaslr-seed = &lt;0x2b1e6ddd 0xe1b43dc9&gt;;\n\t};\n};\nParse DTB from the kernel §\n\nDTB를 파싱하기 위해서 hermit-dtb 라이브러리를 이용하였다.\nqemu에서 시뮬레이션할 Virt Board에서는 RAM의 시작주소인 0x40000000에 dtb를 qemu가 로딩해주므로, 해당 주소를 참조하여 dtb를 확인할 수 있었다.\n\nQEMU Device Tree §\n\ntimer: ARM 타이머 관련..\nintc: GIC 인터럽트 컨트롤러 관련..\npl011: standard output 관련..\nmemory: 0x40000000부터 시작되는 사용가능한 메모리공간의 주소\n\n다만, 0x40000000에는 Device Tree가 로딩되어 있으므로, 적당히 0x40200000부터 사용한다.\n\n\n등등,,\n\nACPI vs Device Tree §\nACPI §\n\nAdvanced Configuration and Power Interface\n주로, X86시스템의 Server/PC에서 사용됨\nACPI started as an interface between firmware (formerly BIOS) and OS for things like power management, but also things like platform device probing\n\n(Flattened) Device Tree §\n\n주로, ARM 기반의 Embedded System에서 사용됨\nDT was always (even long before ACPI existed) about declarative platform device descriptions (probing and configuration), so the OS can properly initialize all drivers, configure operation points, etc, etc.\n\nReference §\n\nhermit-os/hermit-dtb: https://github.com/hermit-os/hermit-dtb\nDevicetree in QEMU: https://docs.u-boot.org/en/latest/develop/devicetree/dt_qemu.html\nDeviceTree Specification: https://devicetree-specification.readthedocs.io/en/stable/index.html\nFlattened Device Tree Format: https://devicetree-specification.readthedocs.io/en/v0.3/flattened-format.html\nDifference between dts and ACPI: https://stackoverflow.com/questions/32310935/difference-between-dts-and-acpi\n"},"Projects/cosmos/05_Bootloading":{"title":"Boot Loading","links":[],"tags":[],"content":"Booting Process §\n\nReverse Engineering from Hermit OS: ARM 부팅과 관련한 배경지식이나 레퍼런스가 x86에 비해 상대적으로 적어, arm기반의 os인 hermit-os의 부팅과정을 참조하며 제작하였다.\nHermit-OS의 booting process는 rust-embedded/rust-raspberrypi-OS-tutorials를 참조하여 만들어져, 이후에는 이를 참조하였다.\n\nHermit Booting Process §\nlink.ld §\n\nEntry Point가 명시되어 있음\n각 섹션의 구조, 메모리상의 위치 등이 정의되어 있음\nDTB는 0x40000000에 로딩되어 있으므로, 이를 덮어쓰지 않기 위해서 0x40200000부터 로딩하도록 함\n\nENTRY(_start)\nphys = 0x40200000;\n \n...(생략)\n \nSECTIONS \n{\n\t. = phys;\n\t...(생략)\n}\nentry.s §\n_start:\n\t...(검증 과정 생략)\n\t...(초기화 과정 생략)\n\t\n\tb _start_rust\n\t\n\t...(생략)\n위와 같이, 검증 및 초기화 과정을 거친 뒤에 _start_rust로 브랜치하여 rust로 제작된 코드로 점프하게 된다.\nentry.rs §\n_start_rust → pre_init → loader_main\n\n_start_rust: calling pre_init\npre_init\n\n초기화 과정 수행..\ndisable interrupts\nreset tid registers\ndisable mmu\nsetup memory attribute type table\nsetup TCU (translation control register)\nenable FP/ASIMD in Architectural Feature Access Control Register\nreset debug control register\nprepare system control register (SCTRL)\n\n\nloader_main\n\ninitialize logging\nfinds kernel\nboots kernel\n\n\n\nInitialize Logging §\n\nDevice Tree에서 /chosen field 의 stdout-path의 주소를 참조\narm의 경우 pl011 디바이스에서 stdout을 수행하는 것으로 확인됨\npl011의 주소는 0x09000000\ndtb에서 0x09000000 주소를 확인하여 해당 주소에 원하는 값을 입력하면 화면에 출력된다.\n\nchosen {\n        stdout-path = &quot;/pl011@9000000&quot;;\n        rng-seed = &lt;0x45efbb7b 0x6d473e1e 0xc4883b80 0x72c67d86 0x5215531b 0x9cb909a4 0x775c5488 0x864f215b&gt;;\n        kaslr-seed = &lt;0x2b1e6ddd 0xe1b43dc9&gt;;\n    };\nFinding Kernel §\nBootloader에서 Kernel을 찾는 과정에서 메모리 정렬과 관련된 이슈로 올바르게 찾지 못하는 문제가 있어 우선 bootloader 부분을 제외한 Kernel을 바로 부팅하는 형태로 구현하였음\nReference §\n\nHermit Kernel: https://hermit-os.org/kernel\nHermit Loader: http://hermit-os.org/loader\n"},"Projects/cosmos/06_Interrupt-Handling-01":{"title":"Interrupt Handling 01","links":["ARM/Exceptions/","ARM/Registers/DAIF"],"tags":[],"content":"ARM Interrupt Structure §\n\nARM 아키텍처의 경우 x86아키텍처와는 다르게 Interrupt를 Exception의 일종으로 받아들인다.\n즉, IDT, IVT가 아닌, Exception Vector Table이 있고, Interrupt 타입인 Exception이 들어오면 어떤 Interrupt인지 그때 확인한 후에 적절한 handler를 실행시켜주어야 한다.\n\nindex\nEnable &amp; Disable Interrupt §\n\nEnable interrupt: asm!(&quot;msr DAIFClr, #0xf&quot;, options(nomem, nostack));\n\nMSR DAIFSet, &lt;Xt&gt;: DAIF |= Xt (OR).. 1인 자릿수의 bit 1로 (마스킹하는거)\nMSR DAIFClr, &lt;Xt&gt;: DAIF &amp;= ~Xt (NAND).. 1인 자릿수의 bit 0으로 (마스킹 안하는거)\n\n\nDisable interrupt: asm!(&quot;msr DAIFClr, #0xf&quot;, options(nomem, nostack));\n\nDAIF\nRegisters used to configure Coretex-M Exceptions §\nhttps://interrupt.memfault.com/blog/arm-cortex-m-exceptions-and-nvic"},"Projects/cosmos/07_Interrupt-Handling-02":{"title":"Interrupt Handling 02","links":["ARM/Processor-Modes"],"tags":[],"content":"ARM Generic Interrupt Controller (GIC) §\nhttps://developer.arm.com/documentation/ihi0069/latest/\nGIC Registers §\n\nGICD: Distributor Registers\nGICR: Redisbutor Registors\nGITS: ITS registers\n\nReference §\n\nGIC Architecture Specification 1.3.3: GIC Control and Configuration\nOS Dev\n\nARM Processor Modes §\nProcessor-Modes\nDevice Tree &amp; Timer §\n\ndevice tree에서 timer property의 구조 확인하여 parsing 하였다.\n\n    timer {\n        interrupts = &lt;0x01 0x0d 0x104 0x01 0x0e 0x104 0x01 0x0b 0x104 0x01 0x0a 0x104&gt;;\n        always-on;\n        compatible = &quot;arm,armv8-timer\\0arm,armv7-timer&quot;;\n    };\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nirqtypeirqirqflagssecure0x010x0d0x104non-secure0x010x0e0x104virtual0x010x0b0x104hypervisor0x010x0a0x104\n\nirq.rs 에 globally access 가능한 gic 선언중..\n\nOnceCell1 (writes only once)\nhttps://stackoverflow.com/questions/72369202/are-mutable-static-primitives-actually-unsafe-if-single-threaded\n\n\n\nReference §\n\nLinux - ARM architected timer: https://kernel.org/doc/Documentation/devicetree/bindings/arm/arch_timer.txt\nLinux - ARM Generic Interrupt Controller, version 3:  https://www.kernel.org/doc/Documentation/devicetree/bindings/interrupt-controller/arm%2Cgic-v3.txt\n\nFootnotes §\n\n\nhttps://doc.rust-lang.org/std/cell/struct.OnceCell.html ↩\n\n\n"},"Projects/cosmos/09_Interrupt-Handling-03":{"title":"Interrupt Handling 02","links":["ARM/Registers/SPSel","ARM/Registers/HCR_EL2","ARM/Registers/VBAR_EL1"],"tags":[],"content":"AArch64 Exception Vector Table §\nARMv7 Exception Vector Table §\n\nReference: https://www.realdigital.org/doc/fb6974fbe87554b433bc0c6df2f14d69\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOffsetVectorMode0x00ResetSupervisor0x04Undefined InstructionUndefined0x08Supervisor CallSupervisor0x0CPrefetch AbortAbort0x10Data AbortAbort0x14Not UsedNA0x18IRQ InterruptIRQ0x1CFIQ InterruptFIQ\nARMv8 Exception Vector Table §\n\nReference: https://developer.arm.com/documentation/den0024/a/CHDEEDDC\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAddressException TypeDescriptionVBAR_ELn +0x000SynchronousCurrent EL with SP0+0x080IRQ/vIRQ^+0x100FIQ/vFIQ^+0x180SError/vSError^+0x200SynchronousCurrent EL with SPx+0x280IRQ/vIRQ^+0x300FIQ/vFIQ^+0x380SError/vSError^+0x400SynchronousLower EL using AArch64+0x480IRQ/vIRQ^+0x500FIQ/vFIQ^+0x580SError/vSError^+0x600SynchronousLower EL using AArch32+0x680IRQ/vIRQ^+0x700FIQ/vFIQ^+0x780SError/vSError^\nStack Pointer Selection §\n MSR SPSel, #Imm1: Select whether to use the default SP_ELx Stack Pointer, or the SP_EL0 Stack Pointer\n\nt: Indicates use of the SP_EL0 Stack Pointer.\nh: Indicates use of the SP_ELx Stack Pointer.\n\nSPSel\nReference §\n\nStack Pointer Selection: https://developer.arm.com/documentation/ddi0500/j/CHDDGJID\n\nRegistering Exception Vector Table §\nException Level Transition from EL2 to EL1 §\narch/aarch64/start.rs\nmov x1, 0x80000000 // HCR_EL2::RW::EL1IsAarch64\nmsr HCR_EL2, x1\nHCR_EL2\nRegistration §\narch/aarch64/exception/mod.rs\nadrp x4 {vector_table}\nadd x4, x4, #:lo12:{vector_table}\nmsr VBAR_EL1, x4\nisb sy\ndsb sy\n\nVBAR_EL1에 Vector Table에 해당하는 주소를 등록하여 Exception이 발생하였을 때에 Exception Vector Table을 참조하여 해당 동작을 실행할 수 있도록 하였다.\n\nVBAR_EL1"},"Projects/cosmos/10_Memory-Layout":{"title":"Memory Layout","links":["Projects/cosmos/Appendix/Virt-Board-Memory-Map"],"tags":[],"content":"우선, virt board의 메모리 구조를 참조하기 위해서 QEMU의 source code에서 memory map을 직접 찾아 확인하였다.\n소스코드는 다음과 같았다.\nVirt-Board-Memory-Map\n즉, 이를 정리하면 다음과 같은 메모리 구조를 가지고 있다.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNAMESTART_ADDREND_ADDRLENBoot Rom RESERVED (0 to 0x08000000)&lt;&lt;&lt;VIRT_FLASH0x000000000x080000000x08000000VIRT_CPUPERIPHS0x080000000x080200000x00020000GICD &amp; GICC sits inside CPU Peripheral space&lt;&lt;&lt;VIRT_GIC_DIST0x080000000x080100000x00010000VIRT_GIC_CPU0x080100000x080200000x00010000VIRT_GIC_V2M0x080200000x080210000x00001000VIRT_GIC_HYP0x080300000x080400000x00010000VIRT_GIC_VCPU0x080400000x080500000x00010000The space in between here is reserved for GICv3 CPU/vCPU/HYP&lt;&lt;&lt;VIRT_GIC_ITS0x080800000x080A00000x00020000This redistributor space allows up to 264kB123 CPUs&lt;&lt;&lt;VIRT_GIC_REDIST0x080A00000x090000000x00F60000VIRT_UART0x090000000x090010000x00001000VIRT_RTC0x090100000x090110000x00001000VIRT_FW_CFG0x090200000x090200180x00000018VIRT_GPIO0x090300000x090310000x00001000VIRT_SECURE_UART0x090400000x090410000x00001000VIRT_SMMU0x090500000x090700000x00020000VIRT_PCDIMM_ACPI0x090700000x090700180x00000018VIRT_ACPI_GED0x090800000x090800040x00000004VIRT_NVDIMM_ACPI0x090900000x090900040x00000004VIRT_PVTIME0x090A00000x090B00000x00010000VIRT_SECURE_GPIO0x090B00000x090B10000x00001000VIRT_MMIO0x0A0000000x0A0002000x00000200VIRT_PLATFORM_BUS0x0C0000000x0E0000000x02000000VIRT_SECURE_MEM0x0E0000000x010000000x01000000VIRT_PCIE_MMIO0x100000000x3EFF00000x2eff0000VIRT_PCIE_PIO0x3EFF00000x3F0000000x00010000VIRT_PCIE_ECAM0x3F0000000x400000000x01000000VIRT_MEM0x400000000x40400000000x4000000000Customizable Area&lt;&lt;&lt;QEMU_DTB0x400000000x402000000x00200000COSMOS_RAM_START0x40200000\n이제 커널의 memory map을 linker script를 이용하여 구성하도록 한다.\n크게 text, rodata, data, bss 섹션이 있으며, stack을 위한 공간도 다음의 코드와 같이 충분히 할당해 주었다.\n/* Parts of this linker script are directly taken from Andre Richters Project:\n * https://github.com/rust-embedded/rust-raspberrypi-OS-tutorials/blob/master/16_virtual_mem_part4_higher_half_kernel/src/bsp/raspberrypi/link.ld \n*/\n \nOUTPUT_FORMAT(&quot;elf64-littleaarch64&quot;)\nOUTPUT_ARCH(&quot;aarch64&quot;)\nENTRY(_start)\nkernel_start = 0x40200000;\n \nPHDRS\n{\n  segment_ro PT_LOAD FLAGS(4); /* 4 == RO */\n  segment_rx PT_LOAD FLAGS(5); /* 5 == RX */\n  segment_rw PT_LOAD FLAGS(6); /* 6 == RW */\n}\n \nSECTIONS\n{\n  . = kernel_start;\n  .text : {\n    __text_start = .;\n    KEEP(*(.text._start))\n    *(.text)\n    *(.text.*)\n    __text_end = .;\n  } :segment_rx\n \n  .rodata : ALIGN(8) {\n    __rodata_start = .;\n    *(.rodata)\n    *(.rodata.*)\n    __rodata_end = .;\n  } :segment_ro\n \n  .got    : ALIGN(8) {\n    /* Global offset table Todo */\n    *(.got)\n  } :segment_ro\n  ASSERT(SIZEOF(.got) == 0, &quot;Relocation Not Supported&quot;)\n \n  .data   : ALIGN(8) {\n    *(.data)\n    *(.data.*)\n  } :segment_rw\n  .bss (NOLOAD)    : ALIGN(16) {\n    __bss_start = .;\n    *(.bss)\n    *(.bss.*)\n    . = ALIGN(16);\n    __bss_end_exclusive = .;\n  } :segment_rw\n  . = ALIGN(4K); /* Align to page boundary */\n  /***********************************************************************************************\n   * Boot Core Stack\n   ***********************************************************************************************/\n  __boot_core_stack_start = .;         /*   ^             */ \n                                       /*   | stack       */\n  . += 16K;                            /*   | growth      */\n                                       /*   | direction   */\n  __boot_core_stack_end_exclusive = .; /*   |             */\n  kernel_end = .;\n}\nLinker Script - Align §\n. = ALIGN(8);\nequals to..\nwhile ((current_location &amp; 7) != 0)\n  *current_location++ = padding_value;\nLinux Memory Layout §\n\nText Segment (=Code Segment) §\n\n프로그램에서 실행할 코드가 위치할 메모리 영역\n쓰기 권한 없음, 실행 권한 있음\n\nData Segment §\n\n컴파일 시에 값이 정해지는 전역 변수\n쓰기 권한 존재\n\nROData Segment §\n\n컴파일 시에 값이 정해지고 변경되지 않는 전역 상수\n쓰기 권한 없음\n\nBSS Segment §\n\n컴파일 시에 초기값이 할당되지 않은 전역변수\n초기값은 0으로 할당되며, 쓰기 권한 존재\n\nHeap Segment §\n\n동적으로 할당받는 메모리의 영역\n\nStack Segment §\n\n프로세스의 스택이 위치하는 메모리 영역\n\nReference §\n\nHermit Kernel: https://hermit-os.org/kernel\nHermit Loader: http://hermit-os.org/loader\nALIGN in Linker Scripts: https://stackoverflow.com/questions/8458084/align-in-linker-scripts\nLinux Memory Layout: https://hackyboiz.github.io/2022/01/14/poosic/linux-memory-layout/\n"},"Projects/cosmos/11_Counter-Timer":{"title":"Counter Timer","links":["ARM/Timer","ARM/Programmer's-Guide/Chapter-12-The-Memory-Management-Unit"],"tags":[],"content":"Timer\nhttps://cirosantilli.com/linux-kernel-module-cheat/arm-timer.html\nVirtual Memory §\n\nARMv8 Programmers Guide: Chapter 12: The Memory Management Unit\nChapter 12 The Memory Management Unit\n"},"Projects/cosmos/12_UART":{"title":"12_UART","links":["ARM/PL011/","ARM/PL011/REGISTERS","ARM/PL011/Interrupts"],"tags":[],"content":"UART §\n\nSerial Communication Protocol &amp; Hardware..\nUART로 키보드 입력 받음\n\nPL011 Register Summary §\nindex\nRegisters §\nREGISTERS\nInterrupt Registers §\nInterrupts\nImplementation §\nInitialization §\nfn init(&amp;mut self) {\n\t// Turn Off UART Temporarily\n\tself.registers.CR.set(0); \n\t// Clear all interrupts\n\tself.registers.ICR.write(ICR::ALL::CLEAR); \n\t// Set Baud Rate\n\tself.registers.IBRD.write(IBRD::BAUD_DIVINT.val(3));\n\tself.registers.FBRD.write(FBRD::BAUD_DIVINT.val(3));\n\t// Set DataFrame as 8bit + FIFO mode\n\tself.registers.LCR_H.write(LCR_H::WLEN::EightBit + LCR_H::FEN::FifosEnabled);\n\tself.registers.IFLS.write(IFLS::RXIFLSEL::OneEights);\n\t// Turn On Interrupt\n\tself.registers.IMSC.write(IMSC::RXIM::Enabled + IMSC::RTIM::Enabled);\n\t// Turn On UART\n\tself.registers.CR.write(CR::UARTEN::Enabled + CR::TXE::Enable + CR::RXE::Enabled);\n}\nWrite Char to Console §\nfn _write_char(&amp;mut self, c: char) {\n\tself._flush();\n\tself.registers.DR.set(c as u32);\n}\nRead Char from Keyboard §\nfn _read_char(&amp;mut self, nonblocking: bool) {\n\tif nonblocking &amp;&amp; self.registers.FR.matches_all(FR::RXFD::SET) {\n\t\treturn None;\n\t}\n\twhile self.registers.FR.matches_all(FR::RXFE::SET) {\n\t\tasm::nop();\n\t}\n\tlet mut c = self.registers.DR.get() as u8 as char;\n\tif c == &#039;\\r&#039; {\n\t\tc = &#039;\\n&#039;;\n\t}\n\tSome(c)\n}\nFlush §\nfn _flush(&amp;self) {\n\twhile self.registers.FR.matches_all(FR::BUSY::SET) {\n\t\tasm::nop();\n\t}\n}"},"Projects/cosmos/13_Debugging---GIC":{"title":"13_Debugging - GIC","links":[],"tags":[],"content":"GIC 오류 해결 §\n+ let gicd_start: *mut u64 = gicd_start as _;\n+ let gicr_start: *mut u64 = gicr_start as _;\n \n// TODO: allocate gicd and gicr to virtualmem\n- let mut gic = unsafe { GicV3::new(&amp;mut gicd_start, &amp;mut gicr_start) };\n+ let mut gic = unsafe { GicV3::new(gicd_start, gicr_start) };\nSGI(Software Generated Interrupt) 작동 확인함 §\n"},"Projects/cosmos/14_Refactoring-&-Timer-IRQ-Based-Handling":{"title":"14_Refactoring & Timer IRQ Based Handling","links":[],"tags":[],"content":"\nInterrupt class 정리\nTimer &amp; Keyboard 인터럽트로 처리하기\n\nInterrupt Class §\npub struct Interrupt {\n    id: u32,\n    trigger: Trigger,\n    prio: u8,\n    name: &amp;&#039;static str,\n    handler: Handler,\n}\n각 Interrupt는 위와 같이 id, trigger, 우선순위, 이름, 핸들러의 정보를 가지고 있다.\n\nTrigger: Edge Trigger / Level Trigger\n우선순위: 0x00(highest) ~ 0xff(lowest)\n\n위와 같은 Interrupt Instance들을 INTERRUPTS 배열에 저장해두어, Interrupt Handling시에 이를 참조한다.\nTimer Interrupt Handler §\nfn timer_handler() {\n\t// Concludes Timer Interrupt\n\tCNTP_CTL_EL0.modify(CNTP_CTL_EL0::ENABLE::CLEAR);\n\t\n\t// (Optional) Set New TVAL\n\tCNTP_TVAL_EL0.set(target);\n\t\n\t// Enable Timer\n\tCNTP_CTL_EL0.modify(CNTP_CTL_EL0::ENABLE::SET + CNTP_CTL_EL0::IMASK::CLEAR);\n}\nCVAL 혹은 TVAL 조건이 만족되어 Timer Interrupt가 발생하면 Interrupt를 Clear 해주고, 새로운 CVAL 혹은 TVAL을 선언해야 한다면 선언 후, 다시 타이머를 작동시키는 과정으로 진행된다."},"Projects/cosmos/15_Debugging---Keyboard-Interrupt":{"title":"15_Debugging - Keyboard Interrupt","links":[],"tags":[],"content":"\n키보드 인터럽트가 활성화되지 않아, 레지스터들을 직접 확인하였으나 올바르게 설정되어 있음을 확인하였다.\nGIC에 키보드 인터럽트를 등록할 때, Priority를 가장 높게 지정하였더니, 키보드 입력이 인터럽트로 들어오게 입력되었다.\n\nKeyboard Interrupt Handler §\nfn handler(&amp;mut self) {\n\tlet pending =  self.registers.MIS.extract();\n\tself.registers.ICR.write(ICR::ALL::CLEAR);\n\tif pending.matches_any(MIS::RXMIS::SET + MIS::RTMIS::SET) {\n\t\twhile let Some(c) = self._read_char() {\n\t\t\tself._write_char(c);\n\t\t}\n\t}\n}\n\n인터럽트가 발생하여 핸들링하지 않으면 \b같은 인터럽트가 무한히 입력되는 것을 확인할 수 있는데, Handler에서 ICR 레지스터에 0을 작성하여 인터럽트를 클리어해주었더니 정상적으로 핸들링이 되었다.\n인터럽트 핸들러에서는 화면에 입력한 문자를 표기하도록 하였다.\n"},"Projects/cosmos/Appendix/Virt-Board-Memory-Map":{"title":"Virt Board Memory Map","links":[],"tags":[],"content":"hw/arm/virt.c\n/* Addresses and sizes of our components.\n * 0..128MB is space for a flash device so we can run bootrom code such as UEFI.\n * 128MB..256MB is used for miscellaneous device I/O.\n * 256MB..1GB is reserved for possible future PCI support (ie where the\n * PCI memory window will go if we add a PCI host controller).\n * 1GB and up is RAM (which may happily spill over into the\n * high memory region beyond 4GB).\n * This represents a compromise between how much RAM can be given to\n * a 32 bit VM and leaving space for expansion and in particular for PCI.\n * Note that devices should generally be placed at multiples of 0x10000,\n * to accommodate guests using 64K pages.\n */\nstatic const MemMapEntry base_memmap[] = {\n    /* Space up to 0x8000000 is reserved for a boot ROM */\n    [VIRT_FLASH] =              {          0, 0x08000000 },\n    [VIRT_CPUPERIPHS] =         { 0x08000000, 0x00020000 },\n    /* GIC distributor and CPU interfaces sit inside the CPU peripheral space */\n    [VIRT_GIC_DIST] =           { 0x08000000, 0x00010000 },\n    [VIRT_GIC_CPU] =            { 0x08010000, 0x00010000 },\n    [VIRT_GIC_V2M] =            { 0x08020000, 0x00001000 },\n    [VIRT_GIC_HYP] =            { 0x08030000, 0x00010000 },\n    [VIRT_GIC_VCPU] =           { 0x08040000, 0x00010000 },\n    /* The space in between here is reserved for GICv3 CPU/vCPU/HYP */\n    [VIRT_GIC_ITS] =            { 0x08080000, 0x00020000 },\n    /* This redistributor space allows up to 2*64kB*123 CPUs */\n    [VIRT_GIC_REDIST] =         { 0x080A0000, 0x00F60000 },\n    [VIRT_UART] =               { 0x09000000, 0x00001000 },\n    [VIRT_RTC] =                { 0x09010000, 0x00001000 },\n    [VIRT_FW_CFG] =             { 0x09020000, 0x00000018 },\n    [VIRT_GPIO] =               { 0x09030000, 0x00001000 },\n    [VIRT_SECURE_UART] =        { 0x09040000, 0x00001000 },\n    [VIRT_SMMU] =               { 0x09050000, 0x00020000 },\n    [VIRT_PCDIMM_ACPI] =        { 0x09070000, MEMORY_HOTPLUG_IO_LEN },\n    [VIRT_ACPI_GED] =           { 0x09080000, ACPI_GED_EVT_SEL_LEN },\n    [VIRT_NVDIMM_ACPI] =        { 0x09090000, NVDIMM_ACPI_IO_LEN},\n    [VIRT_PVTIME] =             { 0x090a0000, 0x00010000 },\n    [VIRT_SECURE_GPIO] =        { 0x090b0000, 0x00001000 },\n    [VIRT_MMIO] =               { 0x0a000000, 0x00000200 },\n    /* ...repeating for a total of NUM_VIRTIO_TRANSPORTS, each of that size */\n    [VIRT_PLATFORM_BUS] =       { 0x0c000000, 0x02000000 },\n    [VIRT_SECURE_MEM] =         { 0x0e000000, 0x01000000 },\n    [VIRT_PCIE_MMIO] =          { 0x10000000, 0x2eff0000 },\n    [VIRT_PCIE_PIO] =           { 0x3eff0000, 0x00010000 },\n    [VIRT_PCIE_ECAM] =          { 0x3f000000, 0x01000000 },\n    /* Actual RAM size depends on initial RAM and device memory settings */\n    [VIRT_MEM] =                { GiB, LEGACY_RAMLIMIT_BYTES },\n};"},"Projects/cosmos/Daily-Notes/2024-03-28":{"title":"2024-03-28","links":[],"tags":[],"content":"음…\n망함\n왜인진 모르겠으나,, uefi 앱으로 제작하니 *.S 파일 컴파일할때 .size 같은 구문들을 이해를 못한다..\n그냥 hermit-loader 참조하여 cosmos-loader 제작중\n진행상황…\nhermit-loader 는 우선 arch/aarch64/entry.S 파일에 __start 라는 곳에서 instruction들을 시작한다..\n초기 과정이 진행된 뒤에는 no_mangle로 지정된 rust 코드로 이동한다.\nb _start_rust\n\nhermit-loader의 경우 _start_rust임..\n이런저런 linking 에 관련한 변수들이 link.ld 에 선언되어있다. (ex. kernel_start, kernel_end, __boot_core_stack_start etc.)\n컴파일러한테.. 링크해달라고 하려면,, rustc에다가 인자 넘겨야되는데 찾아보니,, .cargo/config.toml에다가 인자 써주면 된다.\n[target.&#039;cfg(target_arch=&quot;aarch64&quot;)&#039;]\nrustflags = [&quot;-Clink-arg=-Tsrc/arch/aarch64/link.ld&quot;]\n대충 잡다한 부분들은 복사해서 패스 (필요시 다시 돌아와서 삽질예정..)\nnone.rs 보면, kernel을 찾는 과정이 있는데,, 왜인진 몰라도 처음에 커널을 제대로 못찾았다..\n한번은 elf magic number 일치안하고, 또 한번은 hermit kernel이 아니라고 에러나서,,\n직접 만들어보면서 내 커널에 맞게 개조하기로 했다..\n우선 find_kernel 에서는 dtb 의 chosen 속성중에 module@로 시작하는 속성에 해당하는 메모리 위치를 잡아내서 kernel을 찾아낸다..\n찾아낸 뒤에는 elf magic number 일치하는지 체크하고, kernel file size를 확인한다.\n일치하는지 확인해본 결과 cosmos 커널의 파일사이즈와 정확히 일치하였다.\n그러면 find_kernel 에서 이 파일을 읽어서 [u8] 배열 형태로 넘겨준다..\n다음에 해야할거는 그럼\n\n어지러운 [u8] 에서 필요한 정보 파싱해내기\nmemory에 적재하기\n\n여기까지가 bootloader의 역할인듯 하다."},"Projects/cosmos/Daily-Notes/2024-03-29":{"title":"2024-03-29","links":[],"tags":[],"content":"Linux Memory Layout §\nhttps://hackyboiz.github.io/2022/01/14/poosic/linux-memory-layout/\n\nCode Segment §\n\nR-X\n\nData Segment §\n\nRW-\nR—: rodata\n\nBSS Segment §\n\nGlobal Variable\nRW-\n\nStack Segment §\nHeap Segment §"},"Projects/cosmos/Daily-Notes/2024-04-01":{"title":"2024-04-01","links":[],"tags":[],"content":"Memory Map §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAddressRole0x0boot flash (-bios or pflash)0x09000000UART (pl011)0x40000000Ram Starting point (qemu will load dtb here)0x40200000kernel_start(0x40218000)__boot_core_stack_start (size: 0x4000)(0x4021c000)__boot_core_stack_end_exclusive, kernel_end"},"Projects/cosmos/Daily-Notes/2024-04-03":{"title":"2024-04-03","links":[],"tags":[],"content":"Linker Script §\n/* Parts of this linker script are directly taken from Andre Richters Project:\n * https://github.com/rust-embedded/rust-raspberrypi-OS-tutorials/blob/master/16_virtual_mem_part4_higher_half_kernel/src/bsp/raspberrypi/link.ld\n*/\n \nOUTPUT_FORMAT(&quot;elf64-littleaarch64&quot;)\nOUTPUT_ARCH(&quot;aarch64&quot;)\nENTRY(_start)\nphys = 0x40200000;\n \nPHDRS\n{\n  segment_ro PT_LOAD FLAGS(4); /* 4 == RO */\n  segment_rx PT_LOAD FLAGS(5); /* 5 == RX */\n  segment_rw PT_LOAD FLAGS(6); /* 6 == RW */\n}\n \nSECTIONS\n{\n  . = phys;\n  kernel_start = .;\n  .text : {\n    KEEP(*(.text._start))\n    *(.text)\n    *(.text.*)\n  } :segment_rx\n  .rodata : ALIGN(8) {\n    *(.rodata)\n    *(.rodata.*)\n  } :segment_ro\n  .got    : ALIGN(8) {\n    /* Global offset table Todo */\n    *(.got)\n  } :segment_ro\n  .data   : ALIGN(8) {\n    *(.data)\n    *(.data.*)\n  } :segment_rw\n  .bss    : ALIGN(8) {\n    *(.bss)\n    *(.bss.*)\n  } :segment_rw\n  . = ALIGN(4K); /* Align to page boundary */\n  /***********************************************************************************************\n   * Boot Core Stack\n   ***********************************************************************************************/\n  __boot_core_stack_start = .;         /*   ^             */\n                                       /*   | stack       */\n  . += 16K;                            /*   | growth      */\n                                       /*   | direction   */\n  __boot_core_stack_end_exclusive = .; /*   |             */\n  kernel_end = .;\n}\nInitialization §\n.equ _core_id_mask, 0xff\n \n.section .text._start\n \n_start:\n    // Only proceed on the boot core. Park it otherwise.\n    mrs x1, mpidr_el1\n    and x1, x1, _core_id_mask\n    mov x2, xzr  // Assume CPU 0 is responsible for booting\n    cmp x1, x2\n    b.ne    1f\n \n    // If execution reaches here, it is the boot core. Now, prepare the jump to Rust code.\n \n    // This loads the physical address of the stack end. For details see\n    // https://github.com/rust-embedded/rust-raspberrypi-OS-tutorials/blob/master/16_virtual_mem_part4_higher_half_kernel/src/bsp/raspberrypi/link.ld\n    adrp    x4, __boot_core_stack_end_exclusive\n    add     x4, x4, #:lo12:__boot_core_stack_end_exclusive\n    mov     sp, x4\n \n    // Jump to Rust code.\n    b   _start_cosmos\n \n    // Infinitely wait for events (aka &quot;park the core&quot;).\n1:  wfe\n    b   1b\n \n.size   _start, . - _start\n.type   _start, function\n.global _start\n해석 §\n\nmrs x1, mpidr_el1: assign mpidr_el1[^mpidr_el1] to x1\nand x1, x1, __core_id_mask: x1 = x1 | 0xff\nmov x2, xzr: x2 = 0\ncmp x1, x2; b.ne 1f;: if (x1 != x2) goto 1; (1: loop)\nadrp, add: relocation123.. 결국 x4 = __boot_core_stack_end_exclusive\nmov sp, x4: sp = x4\n\nFootnotes §\n\n\nhttps://casionwoo.tistory.com/25 ↩\n\n\nhttps://sourceware.org/binutils/docs/as/AArch64_002dRelocations.html ↩\n\n\nhttps://stackoverflow.com/questions/64838776/understanding-arm-relocation-example-str-x0-tmp-lo12zbi-paddr ↩\n\n\n"},"Projects/cosmos/Daily-Notes/2024-04-08":{"title":"2024-04-08","links":[],"tags":[],"content":"armv7: https://developer.arm.com/documentation/den0024/a/AArch64-Exception-Handling/AArch64-exception-table?lang=en#BABGIIHH\narmv8: https://developer.arm.com/documentation/den0013/d/Exception-Handling/Exception-priorities?lang=en#CEGHDCAE\nhttps://developer.arm.com/documentation/100932/0100/AArch64-exception-vector-table\nhttps://developer.arm.com/documentation/den0024/a/CHDEEDDC\nAArch64 Exception Vector Table §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAddressException TypeDescriptionVBAR_ELn +0x000SynchronousCurrent EL with SP0+0x080IRQ/vIRQ^+0x100FIQ/vFIQ^+0x180SError/vSError^+0x200SynchronousCurrent EL with SPx+0x280IRQ/vIRQ^+0x300FIQ/vFIQ^+0x380SError/vSError^+0x400SynchronousLower EL using AArch64+0x480IRQ/vIRQ^+0x500FIQ/vFIQ^+0x580SError/vSError^+0x600SynchronousLower EL using AArch32+0x680IRQ/vIRQ^+0x700FIQ/vFIQ^+0x780SError/vSError^"},"Projects/cosmos/Daily-Notes/2024-05-04-GIC":{"title":"2024-05-04 GIC","links":[],"tags":[],"content":"intc@8000000 {\n\tphandle = &lt;0x8002&gt;;\n\tinterrupts = &lt;0x01 0x09 0x04&gt;;\n\treg = &lt;0x00 0x8000000 0x00 0x10000 0x00 0x80a0000 0x00 0xf60000&gt;;\n\t#redistributor-regions = &lt;0x01&gt;;\n\tcompatible = &quot;arm,gic-v3&quot;;\n\tranges;\n\t#size-cells = &lt;0x02&gt;;\n\t#address-cells = &lt;0x02&gt;;\n\tinterrupt-controller;\n\t#interrupt-cells = &lt;0x03&gt;;\n \n\tits@8080000 {\n\t\tphandle = &lt;0x8003&gt;;\n\t\treg = &lt;0x00 0x8080000 0x00 0x20000&gt;;\n\t\t#msi-cells = &lt;0x01&gt;;\n\t\tmsi-controller;\n\t\tcompatible = &quot;arm,gic-v3-its&quot;;\n\t};\n};\nreg = &lt;0x00 0x8000000 0x00 0x10000&gt;,\n\t  &lt;0x00 0x80a0000 0x00 0xf60000&gt;;\nReference §\n\nLinux - ARM architected timer: https://kernel.org/doc/Documentation/devicetree/bindings/arm/arch_timer.txt\nLinux - ARM Generic Interrupt Controller, version 3:  https://www.kernel.org/doc/Documentation/devicetree/bindings/interrupt-controller/arm%2Cgic-v3.txt\n"},"Projects/cosmos/Daily-Notes/index":{"title":"index","links":[],"tags":[],"content":""},"Projects/cosmos/Untitled":{"title":"Untitled","links":[],"tags":[],"content":""},"Projects/cosmos/index":{"title":"cosmos","links":[],"tags":[],"content":"cosmos §\nRust로 제작한 ARM Architecture 기반 교육용 ToyOS §\n\n           Welcome to Project cosmos!\n      \n       _________  _________ ___  ____  _____\n      / ___/ __ \\/ ___/ __ `__ \\/ __ \\/ ___/\n     / /__/ /_/ (__  ) / / / / / /_/ (__  )\n     \\___/\\____/____/_/ /_/ /_/\\____/____/\n\n\n"},"Rust/13-Functional-Language-Features":{"title":"13 Functional Language Features","links":[],"tags":[],"content":""},"index":{"title":"Welcome!","links":[],"tags":[],"content":"\n.repo-card {\n\tmax-width: 500px;\n}\n\n\n\n\nTech Stack §\n\nProgramming Languages\n\n     \n\n\nFrameworks\n\n   \n\n\nServers\n\n     \n\n\nOS\n\n   \n\n\nEditors &amp; Tools\n\n     \n\n\n\nCurrent Project §\n\n학력 §\n\n2015.03 ~ 2018.02 단국대학교 사범대학 부속고등학교 졸업\n2018.03 ~ 2025.02 아주대학교 전자공학과 졸업예정\n2018.03 ~ 2025.02 아주대학교 소프트웨어학과 졸업예정\n\n경력 §\n\n2020.03 ~ 2020.08 한양대학교 의과대학 김이석 교수님 인턴연구원\n2022.07 ~ 2022.12 한양대학교 병원 정보관리팀\n2023.07 ~ 현재 아주대학교 System Software Lab 김상훈 교수님 인턴연구원\n\n수상내역 §\n\n2022.02.23. 디지털 신기술 혁신공유대학 미래자동차 가상환경기반 자율주행 경진대회 대상\n2022.06.08. 국제대학생 자율주행 경진대회 NVIDIA특별상 – 금상\n2022.06.08. 국제대학생 자율주행 경진대회 세계전기차협의회 회장상 – 금상\n2022.12.09. HL만도&amp;HL Klemove 자율주행모빌리티 경진대회 HL만도(주) 대표이사상 – 최우수상\n\nWakatime Status §\n\n\n\n\n\n\nconst lighturl = &#039;https://wakatime.com/share/@parkjbdev/dfae9253-f0df-4ca5-8156-6bf03904a6db.svg&#039;\nconst darkurl = &#039;https://wakatime.com/share/@parkjbdev/625efa64-7aa7-4258-8464-b21271c72545.svg&#039;\n\nconst setJandiTheme = (theme) =&gt; {\n\tconst lightelem = document.querySelector(&#039;#waka-jandi-light&#039;)\n\tconst darkelem = document.querySelector(&#039;#waka-jandi-dark&#039;)\n\tif (theme === &#039;dark&#039;) {\n\t\tlightelem.setAttribute(&#039;style&#039;, &#039;display: none;&#039;)\n\t\tdarkelem.setAttribute(&#039;style&#039;, &#039;display: block;&#039;)\n\t} else {\n\t\tlightelem.setAttribute(&#039;style&#039;, &#039;display: block;&#039;)\n\t\tdarkelem.setAttribute(&#039;style&#039;, &#039;display: none;&#039;)\n\t}\n}\n\nsetJandiTheme(document.documentElement.getAttribute(&#039;saved-theme&#039;))\ndocument.querySelector(&#039;#darkmode-toggle&#039;).addEventListener(&#039;change&#039;, (e) =&gt; setJandiTheme(e.target.checked ? &#039;dark&#039; : &#039;light&#039;))\n\n\n\nconst setRepoTheme = (theme) =&gt; {\n\tconst elems = document.querySelectorAll(&#039;.repo-card&#039;)\n\tfor (const elem of elems) {\n\t\tif (theme === &#039;dark&#039;)\n\t\t\telem.setAttribute(&#039;data-theme&#039;, &#039;dark-theme&#039;)\n\t\telse\n\t\t\telem.setAttribute(&#039;data-theme&#039;, &#039;light-default&#039;)\n\t}\n\twindow.tarptaeya.reloadRepoCards()\n}\nsetRepoTheme(document.documentElement.getAttribute(&#039;saved-theme&#039;))\ndocument.querySelector(&#039;#darkmode-toggle&#039;).addEventListener(&#039;change&#039;, (e) =&gt; setRepoTheme(e.target.checked ? &#039;dark&#039; : &#039;light&#039;))\n"},"뒤죽박죽/2024-02-네트워크-삽질":{"title":"2024-02 네트워크 삽질","links":[],"tags":["linux"],"content":"debian bullseye에서 bookworm으로 업그레이드 한 후에, package dependency가 꼬이는 바람에 삭제하고 설치하는 과정에서 networking 관련된 서비스가 삭제되어 문제가 생긴듯하다.\n처음에는 서버가 연결이 안돼서 아예 안켜진줄 알았으나.. 알고보니 서버는 켜져있었고, 네트워크가 올바르게 로딩되지 않아서 접속이 안됐던것이다.\n그래서 직접 서버실가서 해결해야겠구나.. 싶었던 와중에 교수님께서 ipmitool을 이용해서 서버에 접속하는 방법을 알려주셨다. (당시 제주도였다..)\nipmitool -U &lt;username&gt; -P &lt;password&gt; -I &lt;interface&gt; -H &lt;address&gt; &lt;command&gt;\nMAN: https://linux.die.net/man/1/ipmitool\nIPMI? §\nIPMI는 Intelligent Platform Management Interface의 약자\n하드웨어를 원격으로 관리하는데에 사용되는 인터페이스\n그래서 &lt;command&gt;를 이용해서 서버를 켜고 끄거나(power or chassis), 서버 화면에 표시되는 내용을 원격으로 보는 (sol (serial over lan)) 등의 역할을 수행할 수 있다.\n문제해결 §\n\n우선 다음과 같이 ip a로 확인한 mir4랑 똑같이 세팅을 맞추니 간신히 ssh는 붙었다.\n\nsudo ip address add &lt;ip&gt; dev ibp94s0 brd &lt;ip&gt;\nsudo ip address add &lt;ip&gt; dev eno1 brd &lt;ip&gt;\nsudo brctl addbr br0\nsudo ip address add &lt;bridge ip&gt; dev br0 brd &lt;ip&gt;\nsudo ip link set dev ibp94s0 down\nsudo ip link set dev eno1 down\nsudo ip link set dev ibp94s0 up\nsudo ip link set dev eno1 up\n\n\nsudo apt --fix-broken install 에서 깨진 의존성들을 확인하고 직접 packages.debian.org 에서 wget 으로 다운로드하고 sftp로 보낸뒤에 sudo dpkg -i &lt;package&gt;.deb 로 설치\nnetworking.service 파일이 없어서.. mir4 세팅보고 직접 만들어서 넣어줌\nifupdown2를 alfa 서버에서 wget 명령을 이용해서 다운로드하고 sftp로 보낸뒤에 sudo dpkg -i &lt;package&gt;.deb 로 설치\nping 8.8.8.8 은 되는데 ping google.com은 안되는걸 보고, DNS 세팅이 안됐구나 확인.. systemd-networkd-wait-online.service 실행할때 --any 옵션 붙여줌.. (sudo systemctl edit --full systemd-networkd-wait-online.service) + sudo apt install resolvconf\n/share 폴더 마운트 안돼서 sudo mount -t nfs &lt;ip&gt;:/share /share로 직접 마운트하려 하니 nfs 관련 유틸 없음을 확인.. sudo apt install nfs-common로 설치하니 잘 마운팅됨\napparmor.service dmesg에서 계속 fail 떠서 찾아보니,, snapd가 지워짐.. 마찬가지로 sudo apt install snapd\n\n된당!\n\nvar disqus_config = function () {\n  this.page.url = window.location.hostname;  // Replace PAGE_URL with your page&#039;s canonical URL variable\n  this.page.identifier = window.location.pathname; // Replace PAGE_IDENTIFIER with your page&#039;s unique identifier variable\n};\n(function() { // DON&#039;T EDIT BELOW THIS LINE\n  var d = document, s = d.createElement(&#039;script&#039;);\n  s.src = &#039;https://tech-parkjb.disqus.com/embed.js&#039;;\n  s.setAttribute(&#039;data-timestamp&#039;, +new Date());\n  (d.head || d.body).appendChild(s);\n})();\n\nPlease enable JavaScript to view the comments powered by Disqus."},"뒤죽박죽/Github-Actions":{"title":"Github Actions 으로 obsidian-quartz 블로그 퍼블리시","links":[],"tags":[],"content":"우선 이 블로그를 만들기 위해서..\n\n\n위의 ‘quartz’ 라는 publishing tool을 조금 수정해서 사용하고 있다.\n문득, obsidian에서 수정한 사항을 직접 build하고 publish하는 과정이 귀찮아져서,,\nobsidian vault를 통째로 github에 올리고 push 될때마다 자동으로 publish해주면 좋을 것 같다는 생각에\ngithub action을 이용하여 가능한 방법들을 찾아보았다.\ngithub action을 이용하면 기본적으로 자기 repository 파일들을 받아오는듯\ngithub action은 jobs/steps에 표기된 순서대로 작업이 실행된다고 한다..\n그래서 만든 step들이다.\nStep 01 §\nquartz에서는 obsidian vault가 content라는 폴더로 네이밍 되어있어야 돼서\n\ncontent라는 폴더 만든 뒤\n모든 파일들을 content 폴더 밑으로 이동시켜 주었다\n\n  - name: move entire files to content\n\trun: |\n\t  mkdir content\n\t  shopt -s extglob\n\t  mv -v ./!(content) content/\nStep 02 §\n빌드를 하려면 quartz repository가 필요하다.\nwith 구문을 이용해서 repository를 명시해주고,, quartz라는 폴더로 clone하도록 하였다.\n  - name: Checkout quartz\n\tuses: actions/checkout@v3\n\twith:\n\t  clean: false\n\t  repository: parkjbdev/quartz\n\t  path: ./quartz\n \nStep 03 §\n기본으로 깔린 nodejs 버전이 좀 옛날거같다.\n21버전으로 올려준다.\n      - uses: actions/setup-node@v4\n        with:\n          node-version: 21\nStep 04 §\n아까 content에 넣어둔 vault를 quartz 밑으로 옮겨두고 빌드하기\n  - name: Move Content and change directory \n\trun: |\n\t  mv -v content quartz/content\n\t  cd quartz\n\t  yarn\n\t  yarn quartz build\n\t  pwd\n\t  ls\nStep 05 §\n내 github page에 올려야 되니까.. repository를 clone해왔다..\n근데 유지하고 싶은 파일 있는게 아니라면 굳이안해도 될듯?\nCNAME만 가져오려고 우선 ghpage라는 폴더로 clone하였다.\n  - name: parkjbdev ghpage\n\tuses: actions/checkout@v3\n\twith:\n\t  clean: false\n\t  repository: parkjbdev/parkjbdev.github.io\n\t  path: ./ghpage\nStep 06 §\nclone한 ghpage 폴더로 가서 필요한 파일빼고 다 날려버린다..\n그런 뒤에 quartz에서 빌드한 결과 (quartz/public) 에 있는 파일들을 다 복사해온다\n  - name: clean parkjbdev ghpage and copy from build\n\trun: |\n\t  cd ghpage\n\t  shopt -s extglob\n\t  rm -rf ./!(CNAME)\n\t  cp -r ../quartz/public/** .\n\t  pwd\n\t  ls\n \nStep 07 §\n마지막으로, github page에 commit하고 push한다..\npush 권한 얻으려면 personal token이나 ssh deploy key 발급해서 등록해야되는데, 보안이슈 때문에 ssh deploy key를 권장한다고 한다.\nssh-keygen 해서 하나 만들어주고,\n- push할 repository에는 deploy key에 퍼블릭키를,\n- action이 수행되는 지금 이 repository에는 github action secret 키에 프라이빗 키를 등록해준다. (ssh deploy key 쓰면 아래처럼 DEPLOY_PRIVATE_KEY)\n자세한건 https://cpina.github.io/push-to-another-repository-docs/index.html 참조하기..\n  - name: Deploy to external repository\n\tuses: cpina/github-action-push-to-another-repository@main\n\tenv:\n\t  SSH_DEPLOY_KEY: ${{ secrets.DEPLOY_PRIVATE_KEY }}\n \n\twith:\n\t  source-directory: ghpage\n\t  destination-github-username: parkjbdev \n\t  destination-repository-name: parkjbdev.github.io \n\t  user-email: dev@parkjb.com \npublish.yml 전문 §\nname: Publish \n \non:\n  push:\n    branches: [ &quot;main&quot; ]\n  pull_request:\n    branches: [ &quot;main&quot; ]\n \n  workflow_dispatch:\n \njobs:\n  build:\n    runs-on: ubuntu-latest\n \n    steps:\n      - uses: actions/checkout@v3\n \n\t# Step 01\n      - name: move entire files to content\n        run: |\n          mkdir content\n          shopt -s extglob\n          mv -v ./!(content) content/\n \n\t# Step 02\n      - name: Checkout quartz\n        uses: actions/checkout@v3\n        with:\n          clean: false\n          repository: parkjbdev/quartz\n          path: ./quartz\n \n\t# Step 03\n      - uses: actions/setup-node@v4\n        with:\n          node-version: 21\n    \n    # Step 04\n      - name: Move Content and change directory \n        run: |\n          mv -v content quartz/content\n          cd quartz\n          yarn\n          yarn quartz build\n          pwd\n          ls\n    # Step 05\n      - name: parkjbdev ghpage\n        uses: actions/checkout@v3\n        with:\n          clean: false\n          repository: parkjbdev/parkjbdev.github.io\n          path: ./ghpage\n\t# Step 06\n      - name: clean parkjbdev ghpage and copy from build\n        run: |\n          cd ghpage\n          shopt -s extglob\n          rm -rf ./!(CNAME)\n          cp -r ../quartz/public/** .\n          pwd\n          ls\n    # Step 07\n      - name: Deploy to external repository\n        uses: cpina/github-action-push-to-another-repository@main\n        env:\n          SSH_DEPLOY_KEY: ${{ secrets.DEPLOY_PRIVATE_KEY }}\n \n        with:\n          source-directory: ghpage\n          destination-github-username: parkjbdev \n          destination-repository-name: parkjbdev.github.io \n          user-email: dev@parkjb.com \n\n\nvar disqus_config = function () {\n  this.page.url = window.location.hostname;  // Replace PAGE_URL with your page&#039;s canonical URL variable\n  this.page.identifier = window.location.pathname; // Replace PAGE_IDENTIFIER with your page&#039;s unique identifier variable\n};\n(function() { // DON&#039;T EDIT BELOW THIS LINE\n  var d = document, s = d.createElement(&#039;script&#039;);\n  s.src = &#039;https://tech-parkjb.disqus.com/embed.js&#039;;\n  s.setAttribute(&#039;data-timestamp&#039;, +new Date());\n  (d.head || d.body).appendChild(s);\n})();\n\nPlease enable JavaScript to view the comments powered by Disqus."},"뒤죽박죽/OpenCV-on-mac":{"title":"[OpenCV] Xcode OpenCV 설치 및 세팅","links":[],"tags":[],"content":"OpenCV 설치 §\nbrew install opencv\nDependency들 많아서 조금 걸림\nOpenCV Library &amp; Header 추가 §\nHeader &amp; Library 추가 §\n\nTargets - Build Settings에서 다음과 같이 설정\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSetting경로Library Search Path/opt/homebrew/Cellar/opencv/버전명/libHeader Search Path/opt/homebrew/Cellar/opencv/버전명/include/opencv4\nDisable Library Validation §\n\nDisable Library Validation 항목 체크해줄것\n이거 안하면 라이브러리 못불러온다고 에러남\n\n카메라 쓰면 그 밑에 Resource Access에서 Camera도 켜줄것!! Info.plist 만들고 할 필요 없습니다\n\nOpenCV pkg-config 플래그 확인 &amp; 추가 §\n$ pkg-config --cflags --libs /opt/homebrew/Cellar/opencv/버전명/lib/pkgconfig/opencv4.pc\n전 이렇게 나왔음\n-I/opt/homebrew/opt/opencv/include/opencv4 -L/opt/homebrew/opt/opencv/lib -lopencv_gapi -lopencv_stitching -lopencv_alphamat -lopencv_aruco -lopencv_barcode -lopencv_bgsegm -lopencv_bioinspired -lopencv_ccalib -lopencv_dnn_objdetect -lopencv_dnn_superres -lopencv_dpm -lopencv_face -lopencv_freetype -lopencv_fuzzy -lopencv_hfs -lopencv_img_hash -lopencv_intensity_transform -lopencv_line_descriptor -lopencv_mcc -lopencv_quality -lopencv_rapid -lopencv_reg -lopencv_rgbd -lopencv_saliency -lopencv_sfm -lopencv_stereo -lopencv_structured_light -lopencv_phase_unwrapping -lopencv_superres -lopencv_optflow -lopencv_surface_matching -lopencv_tracking -lopencv_highgui -lopencv_datasets -lopencv_text -lopencv_plot -lopencv_videostab -lopencv_videoio -lopencv_viz -lopencv_wechat_qrcode -lopencv_xfeatures2d -lopencv_shape -lopencv_ml -lopencv_ximgproc -lopencv_video -lopencv_xobjdetect -lopencv_objdetect -lopencv_calib3d -lopencv_imgcodecs -lopencv_features2d -lopencv_dnn -lopencv_flann -lopencv_xphoto -lopencv_photo -lopencv_imgproc -lopencv_core\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSetting경로Other Linker Flags위에 저거 복붙하기\nTest §\n코드는 https://docs.opencv.org/4.x/d8/dfe/classcv_1_1VideoCapture.html 에서 베껴옴\ndevideID는 적당히 바꿔가면서 올바르게 넣어보도록 한다\n전 1번 나옴\n#include &lt;opencv2/core.hpp&gt;\n#include &lt;opencv2/videoio.hpp&gt;\n#include &lt;opencv2/highgui.hpp&gt;\n#include &lt;iostream&gt;\n \nusing namespace cv;\nusing namespace std;\nint main(int, char**)\n{\n    Mat frame;\n    //--- INITIALIZE VIDEOCAPTURE\n    VideoCapture cap;\n    // open the default camera using default API\n    // cap.open(0);\n    // OR advance usage: select any API backend\n    int deviceID = 1;             // 0 = open default camera\n    int apiID = CAP_ANY;      // 0 = autodetect default API\n    // open selected camera using selected API\n    cap.open(deviceID, apiID);\n    // check if we succeeded\n    if (!cap.isOpened()) {\n        cerr &lt;&lt; &quot;ERROR! Unable to open camera\\n&quot;;\n        return -1;\n    }\n    //--- GRAB AND WRITE LOOP\n    cout &lt;&lt; &quot;Start grabbing&quot; &lt;&lt; endl\n        &lt;&lt; &quot;Press any key to terminate&quot; &lt;&lt; endl;\n    for (;;)\n    {\n        // wait for a new frame from camera and store it into &#039;frame&#039;\n        cap.read(frame);\n        // check if we succeeded\n        if (frame.empty()) {\n            cerr &lt;&lt; &quot;ERROR! blank frame grabbed\\n&quot;;\n            break;\n        }\n        // show live and wait for a key with timeout long enough to show images\n        imshow(&quot;Live&quot;, frame);\n        if (waitKey(5) &gt;= 0)\n            break;\n    }\n    // the camera will be deinitialized automatically in VideoCapture destructor\n    return 0;\n}\n \n잘된다!\n\n\nvar disqus_config = function () {\n  this.page.url = window.location.hostname;  // Replace PAGE_URL with your page&#039;s canonical URL variable\n  this.page.identifier = window.location.pathname; // Replace PAGE_IDENTIFIER with your page&#039;s unique identifier variable\n};\n(function() { // DON&#039;T EDIT BELOW THIS LINE\n  var d = document, s = d.createElement(&#039;script&#039;);\n  s.src = &#039;https://tech-parkjb.disqus.com/embed.js&#039;;\n  s.setAttribute(&#039;data-timestamp&#039;, +new Date());\n  (d.head || d.body).appendChild(s);\n})();\n\nPlease enable JavaScript to view the comments powered by Disqus."},"뒤죽박죽/Rosetta+Conda-Env-Setting":{"title":"[Conda] Rosetta + Conda Env 세팅","links":[],"tags":[],"content":"CONDA_SUBDIR=osx-64 conda create -n &lt;콘다환경이름&gt; python=&lt;파이썬 버전&gt;\nconda activate &lt;콘다환경이름&gt;\n# 확인 &amp; 환경변수 세팅\npython -c &quot;import platform;print(platform.machine())&quot;\nconda env config vars set CONDA_SUBDIR=osx-64  # make sure that conda commands in this environment use intel packages\n# Re-Activate Conda Environment\nconda deactivate &lt;콘다환경이름&gt;\nconda activate &lt;콘다환경이름&gt;\n# Check\necho &quot;CONDA_SUBDIR: $CONDA_SUBDIR&quot;\nhttps://github.com/conda-forge/miniforge/issues/165\n생각보다 간단하게된다..!\n\n\nvar disqus_config = function () {\n  this.page.url = window.location.hostname;  // Replace PAGE_URL with your page&#039;s canonical URL variable\n  this.page.identifier = window.location.pathname; // Replace PAGE_IDENTIFIER with your page&#039;s unique identifier variable\n};\n(function() { // DON&#039;T EDIT BELOW THIS LINE\n  var d = document, s = d.createElement(&#039;script&#039;);\n  s.src = &#039;https://tech-parkjb.disqus.com/embed.js&#039;;\n  s.setAttribute(&#039;data-timestamp&#039;, +new Date());\n  (d.head || d.body).appendChild(s);\n})();\n\nPlease enable JavaScript to view the comments powered by Disqus."},"뒤죽박죽/Rosetta+Conda-ROS-Setting":{"title":"[ROS] Rosetta + Conda로 ROS 세팅","links":[],"tags":[],"content":"Robostack 이용하면 애플실리콘 기반 맥에서도 ROS사용이 가능하다!\n그런데 rosbridge-server 같은 패키지들이 osx-64로만 제공이 되어 직접빌드를 하여 설치해야 됐다. (이 방법이 익숙하다면 arm64 환경으로 하는것이 더 좋을 것 같다..!)\n그런데 최근에 Rosetta를 이용한 해결법을 발견하여 공유하고자 한다😊\n참고: https://velog.io/@parkjbdev/Rosetta-Conda-Env-세팅\nROS1 (Noetic) §\nhttps://github.com/RoboStack/ros-noetic\n# if you don&#039;t have mamba yet, install it first in the base environment (not needed when using mambaforge):\nconda install mamba -c conda-forge\n \n# Create ros1 conda environment on osx-64\nCONDA_SUBDIR=osx-64 conda create -n ros1 python=3.9\n \n# 확인 &amp; 환경변수 세팅\npython -c &quot;import platform;print(platform.machine())&quot;\nconda env config vars set CONDA_SUBDIR=osx-64\n \n# Re-Activate Conda Environment\nconda deactivate ros1\nconda activate ros1\n \n# Check if config var is setted\necho &quot;CONDA_SUBDIR: $CONDA_SUBDIR&quot;\n \nmamba install ros-noetic-desktop-full -c robostack -c robostack-experimental -c conda-forge --no-channel-priority --override-channels\n \n# optionally, install some compiler packages if you want to e.g. build packages in a catkin_ws:\nmamba install compilers cmake pkg-config make ninja\n \n# on linux and osx (but not Windows) you might want to:\nmamba install catkin_tools\n \nconda deactivate\nconda activate robostackenv\n \n# if you want to use rosdep, also do:\nmamba install rosdep\nrosdep init  # note: do not use sudo!\nrosdep update\n필요한 패키지들이 있다면 여기서 검색해보자 (ex. ros-noetic-rosbridge-server)\nhttps://anaconda.org/search?q=rosbridge\nROS2 (Galactic) §\nhttps://github.com/RoboStack/ros-galactic\n사소한 팁 §\nros conda 환경에서 ls 할때 색깔이 안나왔는데, coreutils가 설치되면서 시스템의 ls보다 우선하여 실행되는듯하다. 나는 그냥 $CONDA_PREFIX/bin에서 ls파일을 지워버렸다. (coreutils의 ls와 맥의 ls가 조금 다른면이 있지만 대부분의 상황에선 잘돌아갈것으로 생각한다)\n\n\nvar disqus_config = function () {\n  this.page.url = window.location.hostname;  // Replace PAGE_URL with your page&#039;s canonical URL variable\n  this.page.identifier = window.location.pathname; // Replace PAGE_IDENTIFIER with your page&#039;s unique identifier variable\n};\n(function() { // DON&#039;T EDIT BELOW THIS LINE\n  var d = document, s = d.createElement(&#039;script&#039;);\n  s.src = &#039;https://tech-parkjb.disqus.com/embed.js&#039;;\n  s.setAttribute(&#039;data-timestamp&#039;, +new Date());\n  (d.head || d.body).appendChild(s);\n})();\n\nPlease enable JavaScript to view the comments powered by Disqus."},"뒤죽박죽/index":{"title":"🤪 뒤죽박죽","links":[],"tags":[],"content":""},"뒤죽박죽/nginx-certbot":{"title":"nginx certbot","links":[],"tags":[],"content":"sudo certbot certonly --manual -d *.parkjb.com -d parkjb.com --preferred-challenges dns\n"}}