{"Flutter/GetX-vs-BLoC-vs-Provider":{"title":"GetX vs BLoC vs Provider","links":[],"tags":[],"content":"Reference §\nFlutter 인기 아키텍처 라이브러리 3종 비교 분석 - GetX vs BLoC vs Provider"},"Linux-Kernel-Labs/Character-Device-Drivers":{"title":"Character Device Drivers","links":[],"tags":[],"content":"Overview §\nUNIX 시스템에서는 모든 장치들을 파일로 취급한다.\n/dev 디렉토리에는 시스템에 연결된 모든 장치들이 파일 형태로 존재하고, open, write, close, lseek, mmap 등의 시스템 콜을 통해 운영체제에서 device driver로 접근할 수 있다.\nDevice Drivers: Character &amp; Block §\n\n나누는 기준\n\nspeed\nvolume\n시스템과 디바이스 간 데이터 전송 방식\n{/* - way of organizing data to be transferred from the device to the system and vice versa */}\n\n\n\nCharacter Device Drivers §\n\n느린 장치들\n적은 양의 데이터를 관리한다.\n데이터에 접근하기 위해서 seek 쿼리를 자주 사용하지 않아도 됨\n주로, 이러한 장치들에서의 Operation(Read, Write)는 Byte 단위로 순차적으로 이루어짐\n예시: 키보드, 마우스, 시리얼 포트, 사운드 카드, 조이스틱 등\n\nBlock Device Drivers §\n\n데이터 볼륨이 큰 장치들\n블록 단위로 데이터를 관리하는 장치들\n검색이 잦은 장치들\n데이터 Block 단위로 Operation이 수행됨\n시스템 콜에 의해 직접 다룰 수 없고, 파일 관리 subsystem과 block device subsystem을 통해 user-space와 block device driver가 소통함\n예시: 하드 디스크, CD-ROM 드라이브, 램 등\n\nMajors and Minors §\n\nMajor: Device Type (IDE disk, SCSI disk, serial port 등)\nMinor: Device Instance (IDE disk 1, IDE disk 2, serial port 1, serial port 2 등)\n\nlinux/Documentation/admin-guide/devices.txt에서 모든 Major, Minor 번호를 확인할 수 있다.\nAllocation §\n\nStatic Allocation\nDynamic Allocation\n\nCreate a Device File §\nmknod &lt;device_file&gt; &lt;type&gt; &lt;major&gt; &lt;minor&gt;\nmknod /dev/mycdev c 42 0 # character device\nmknod /dev/mybdev b 42 0 # block device\nExamples §\nls -al $(find /dev -maxdepth 1 -type c) # character devices\nls -al $(find /dev -maxdepth 1 -type b) # block devices\n\nData structures for a Character Device §\nstruct file_operations §\nhttps://github.com/torvalds/linux/blob/0dd3ee31125508cd67f7e7172247f05b7fd1753a/include/linux/fs.h#L1916\nstruct file_operations\n "},"Linux-Kernel-Labs/Kernel-API":{"title":"Kernel API","links":[],"tags":[],"content":"Kernel API §\nMemory Allocation: kmalloc &amp; kfree §\n#include &lt;linux/slab.h&gt;\n \nstring = kmalloc(string_len + 1, GFP_KERNEL);\nkmalloc §\nvoid * kmalloc (size_t size, gfp_t flags);\n\nsize_t size: how many bytes of memory are required.\ngfp_t flags: the type of memory to allocate.\n\nGFP_KERNEL: Allocation may sleep.\nGFP_NOWAIT: Allocation will not sleep.\nGFP_ATOMIC: Allocation will not sleep. May use emergency pools.\nand more…\n\n\n\nkfree §\nvoid kfree(const void *object)\nSpinLock §\n#include &lt;linux/spinlock.h&gt;\n \nDEFINE_SPINLOCK(lock1);\nspinlock_t lock2;\n \nspin_lock_init(&amp;lock2);\n \nspin_lock(&amp;lock1);\n/* critical region */\nspin_unlock(&amp;lock1);\n \nspin_lock(&amp;lock2);\n/* critical region */\nspin_unlock(&amp;lock2);\nstatic int sched_spin_init(void)\n{\n  DEFINE_SPINLOCK(lock);\n  spin_lock(&amp;lock);\n  set_current_state(TASK_INTERRUPTIBLE);\n  // schedule_timeout(5 * HZ); // Error: &quot;Scheduling while atomic&quot;\n  // &quot;Scheduling while atomic&quot; indicates that you&#039;ve tried to sleep somewhere that you shouldn&#039;t.\n  spin_unlock(&amp;lock);\n}\nExcercise §\n4. Working with kernel lists §\n5. Working with kernel lists for process handling §\n6. Synchronizing list work §\nDEFINE_RWLOCK to lock the list.\nDEFINE_RWLOCK(list_rwlock);\n \nread_lock(&amp;list_rwlock);\n// Critical Section\n// Read only access to the list\nread_unlock(&amp;list_rwlock);\n의문: list_rwlock과 lock사이의 연관성이 없는데 어떻게 lock이 걸리는지..?"},"Linux/mknod":{"title":"mknod","links":[],"tags":[],"content":"Usage §\nmknod NAME TYPE [MAJOR MINOR]\n\nTYPE: b, c, p, u\nMAJOR: major number\nMINOR: minor number\n\nCreate a character device §\nmknod /dev/zero c 1 5"},"Projects/Cookie":{"title":"Cookie","links":[],"tags":[],"content":""},"Projects/WePlan":{"title":"WePlan","links":[],"tags":[],"content":""},"Projects/cosmOS/02_VGA":{"title":"02_VGA","links":[],"tags":[],"content":"VGA Text Mode §\nVGA Text Buffer §\n\nVGA Text Buffer: 25 rows X 80 cols\nEach array entry with following format\n\n| 0                | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8                | 9   | 10  | 11  | 12               | 13  | 14  | 15    |\n| ---------------- | --- | --- | --- | --- | --- | --- | --- | ---------------- | --- | --- | --- | ---------------- | --- | --- | ----- |\n| ASCII code point | &lt;   | &lt;   | &lt;   | &lt;   | &lt;   | &lt;   | &lt;   | Foreground Color | &lt;   | &lt;   | &lt;   | Background Color | &lt;   | &lt;   | Blink |\n\n\n\nFirst Byte: ASCII (exactly, cp437)\n\n\nVGA text buffer is accessible via memory-mapped I/O to the address 0xb8000\n\nDirectly access the Text Buffer on the VGA hardware (without accessing RAM)\nWe can Read/Write through normal memory operations to that address\n\n\n\nA Rust Module §\nColors §\n// in src/vga_buffer.rs\n \n#[allow(dead_code)]\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n#[repr(u8)]\npub enum Color {\n    Black = 0,\n    Blue = 1,\n    Green = 2,\n    Cyan = 3,\n    Red = 4,\n    Magenta = 5,\n    Brown = 6,\n    LightGray = 7,\n    DarkGray = 8,\n    LightBlue = 9,\n    LightGreen = 10,\n    LightCyan = 11,\n    LightRed = 12,\n    Pink = 13,\n    Yellow = 14,\n    White = 15,\n}\n// in src/vga_buffer.rs\n \n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n#[repr(transparent)]\nstruct ColorCode(u8);\n \nimpl ColorCode {\n    fn new(foreground: Color, background: Color) -&gt; ColorCode {\n        ColorCode((background as u8) &lt;&lt; 4 | (foreground as u8))\n    }\n}\nText Buffer §\n// in src/vga_buffer.rs\n \n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n#[repr(C)]\nstruct ScreenChar {\n    ascii_character: u8,\n    color_code: ColorCode,\n}\n \nconst BUFFER_HEIGHT: usize = 25;\nconst BUFFER_WIDTH: usize = 80;\n \n#[repr(transparent)]\nstruct Buffer {\n    chars: [[ScreenChar; BUFFER_WIDTH]; BUFFER_HEIGHT],\n}"},"Projects/cosmOS/Introduction":{"title":"cosmOS - Rust based OS","links":[],"tags":[],"content":"Project cosmOS is a project to create a new operating system for the x86 architecture.\nThe project is currently in the planning phase.\nThis project is based on the Writing an OS in Rust tutorial."},"index":{"title":"Welcome!","links":[],"tags":[],"content":"\nProgramming Languages §\n\n\n\n\n\n\nFrameworks, Platforms and Libraries §\n\n\n\n\nSevers &amp; Databases §\n\n\n\n\n\n\nEnvironments &amp; Tools §\n\n\n\n\n\n\n\n\n\n\n학력 §\n\n2015.03 ~ 2018.02 단국대학교 사범대학 부속고등학교 졸업\n2018.03 ~ 아주대학교 전자공학과 졸업예정\n2018.03 ~ 아주대학교 소프트웨어학과 졸업예정\n\n경력 §\n\n2020.03 ~ 2020.08 한양대학교 의과대학 김이석 교수님 인턴연구원\n2022.07 ~ 2022.12 한양대학교 병원 정보관리팀\n2024.01 ~ 2024.03 한양대학교 의과대학 김이석 교수님 인턴연구원\n2023.07 ~ 아주대학교 System Software Lab 김상훈 교수님 인턴연구원\n\n수상내역 §\n\n2022.02.23. 디지털 신기술 혁신공유대학 미래자동차 가상환경기반 자율주행 경진대회 대상\n2022.06.08. 국제대학생 자율주행 경진대회 NVIDIA특별상 – 금상\n2022.06.08. 국제대학생 자율주행 경진대회 세계전기차협의회 회장상 – 금상\n2022.12.09. HL만도&amp;HL Klemove 자율주행모빌리티 경진대회 HL만도(주) 대표이사상 – 최우수상\n"}}